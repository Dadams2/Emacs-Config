#+title: Doom Emacs Configuration
#+author: Dadams

* Preamble

I don't really know what I am doing, but it seems fun. If you want an actual representation of something good check out [[https://tecosaur.github.io/emacs-config/config.html][Tecosaurs Config]].


* The simple stuff

apparently this makes things run faster (I found it [[https://nullprogram.com/blog/2016/12/22/][here]])
#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src

** Personal info

From ~GPG~ to ~git~ to email clients and snippets, the following seems kinda important to have around
#+begin_src emacs-lisp
(setq user-full-name "David Adams"
      user-mail-address "dbadams@iinet.net.au")
#+end_src

*** GPG
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

** Default settings

*** Common settings
Following in Tec's footsteps I somehow stumbled upon [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]] which gave some inspiration on better default settings

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t ; its rubbish bin not trash
 window-combination-resize t ; take all new space
 x-stretch-cursor t          ; deal with glyphs
 enable-local-variables t    ; I want to be able to use dir-locals
 )


(setq
 undo-limit 2000000
 evil-want-fine-undo t          ; make undo limit bigger
 auto-save-default t            ; help with the b-s
 truncate-string-ellipsis "â€¦"   ; is nicer
 compilation-scroll-output t    ; warnings annoy me
)
#+end_src

***  Frame sizing

Creating a new full-size window each time we want a new frame does not seem ideal. Especially considering window managers
make it easy to snap windows into the correct place

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src


***  Window Splitting

I always want new windows to be to the right

#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src
and when I do I would like to be promoted for what buffer to switch to


#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

**  Doom Config

*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
You have probable seen a ~how to install~ section at the top of a bunch of emacs pages. Doom has it so that you remove a comment
and that's it. There are also extra features that can be added to some of the modules with a =+<somtehing>=

#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no

;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom! :input
;;chinese
;;japanese
;;layout            ; auie,ctsrnm is the superior home row

:completion
    <<doom-completion>>

:ui
    <<doom-ui>>

:editor
    <<doom-editor>>

:term
    <<doom-term>>

:checkers
    <<doom-checkers>>

:tools
    <<doom-tools>>

:os
    <<doom-os>>

:lang
    <<doom-lang>>

:email
    <<doom-email>>

:app
    <<doom-app>>

:config
    <<doom-config>>

) ;lol don't forget this closing brace like I did
#+end_src

**** Config's config

If you don't know what a literate configuration is, welcome! You are reading one.
Doom has some rather nice defaults for literate src_elisp{:config}
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Completion

#+name: doom-completion
#+begin_src emacs-lisp
(company            ; the ultimate code completion backend
 +childframe)       ; ... when the children are actually better
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;;(ivy
;; +icons                 ; a search engine for love and life
;;)
(vertico +icons)    ; search endine for the future
#+end_src

**** General UI

Some are doom specific whilst others are nice quality of life improvements

#+name: doom-ui
#+begin_src emacs-lisp
;;deft              ; notational velocity for Emacs
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
doom-quit         ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)  ; ðŸ™‚
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra
;;indent-guides     ; highlighted indent columns
(ligatures +extra)         ; ligatures and symbols to make your code pretty again
minimap           ; show a map of the code on the side
modeline          ; snazzy, Atom-inspired modeline, plus API
nav-flash         ; blink cursor line after big motions
;;neotree           ; a project drawer, like NERDTree for vim
ophints           ; highlight the region an operation acts on
(popup +defaults +all)   ; tame sudden yet inevitable temporary windows
(tabs +centaur-tabs)             ; a tab bar for Emacs and prettyer tabs
treemacs          ; a project drawer, like neotree but cooler
unicode           ; extended unicode support for various languages
vc-gutter         ; vcs diff in the fringe
vi-tilde-fringe   ; fringe tildes to mark beyond EOB
(window-select +numbers)    ; visually switch windows
workspaces        ; tab emulation, persistence & separate workspaces
zen               ; distraction-free coding or writing

#+end_src

**** Editor things

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
(format +onsave)  ; automated prettiness
;;god               ; run Emacs commands without modifier keys
;;lispy             ; vim for lisp, for people who don't like vim
multiple-cursors  ; editing in many places at once
;;objed             ; text object editing for the innocent
;;parinfer          ; turn lisp into python, sort of
;;rotate-text       ; cycle region at point between text candidates
snippets          ; my elves. They type so I don't have to
;;word-wrap         ; soft wrapping with language-aware indent

:emacs
(dired +icons)            ; making dired pretty [functional]
electric          ; smarter, keyword-based electric-indent
(ibuffer +icons)       ; interactive buffer management
undo              ; persistent, smarter undo for your inevitable mistakes
vc                ; version-control and Emacs, sitting in a tree
#+end_src

**** Terminals

whilst vterm is the best terminal emulator inside emacs currently, it is the most painful thing to compile (with
the exception of maybe pdftools). As such having alternatives can be useful

#+name: doom-term
#+begin_src emacs-lisp
eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell REPL for Emacs
;;term              ; basic terminal emulator for Emacs
vterm             ; the best terminal emulation in Emacs
#+end_src

**** Checkers

not much to be said. Flyspell good.
#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
(spell +flyspell) ; tasing you for misspelling mispelling
grammar           ; tasing grammar mistake every you make
#+end_src


**** Other stuff

despite the name herein lies some of the things that make emacs worth using.

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
;;debugger          ; FIXME stepping through code, to help you add bugs
;;direnv
docker
editorconfig      ; let someone else argue about tabs vs spaces
;;ein               ; tame Jupyter notebooks with emacs
(eval +overlay)     ; run code, run (also, repls)
;;gist              ; interacting with github gists
lookup              ; navigate your code and its documentation
lsp               ; M-x vscode
(magit +forge)    ; a git porcelain for Emacs
make              ; run make tasks from Emacs
;;pass              ; password manager for nerds
pdf               ; pdf enhancements
;;prodigy           ; FIXME managing external services & code builders
rgb               ; creating color strings
taskrunner        ; taskrunner for all your projects
;;terraform         ; infrastructure as code
tmux              ; an API for interacting with tmux
upload            ; map local to remote projects via ssh/ftp
#+end_src
#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)  ; improve compatibility with macOS
tty               ; improve the terminal Emacs experience
#+end_src


**** Languages

#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
(cc +lsp)                ; C > C++ == 1
;;clojure           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .NET, and mono shenanigans
data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;elixir            ; erlang done right
;;elm               ; care for a cup of TEA?
emacs-lisp        ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(haskell +dante)  ; a language that's lazier than I am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
json              ; At least it ain't XML
(java +meghanada +lsp) ; the poster child for carpal tunnel syndrome
(javascript +lsp)        ; all(hope(abandon(ye(who(enter(here))))))
;;(julia +lsp)             ; a better, faster MATLAB
;;kotlin            ; a better, slicker Java(Script)
;;latex             ; writing papers in Emacs has never been so fun
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
;;lua               ; one-based indices? one-based indices
markdown          ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
;;nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org
+pretty
+jupyter)                                ; organize your plain life in plain text
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
(python +lsp +pyright +conda +cython)           ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rest              ; Emacs as a REST client
;;rst               ; ReST in peace
;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;(scheme +guile)   ; a fully conniving family of lisps
sh                ; she sells {ba,z,fi}sh shells on the C xor
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
web               ; the tubes
yaml              ; JSON, but readable
;;zig               ; C, but simpler
#+end_src


**** Bring it all in

A constant work in progress. But trying to understand it does teach you a bunch.

#+name: doom-email
#+begin_src emacs-lisp
;;(mu4e +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

there are other things to consider as well
#+name: doom-app
#+begin_src emacs-lisp
;;calendar
;;emms
everywhere        ; *leave* Emacs!? You must be joking
;;irc               ; how neckbeards socialize
;;(rss +org)        ; emacs as an RSS reader
;;twitter           ; twitter client https://twitter.com/vnought
#+end_src


*** General Visual

**** Fonts

watch this space

**** Theme and modeline

I like the softer look of Nord and use it in a number of other places. There are some disadvantages like weird comments
but overall its nice.

#+begin_src emacs-lisp

(setq doom-theme 'doom-nord)

#+end_src

I use linux on all my systems so I don't need to be told that =LF UTF-8= is my file encoding all the time
 #+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
"We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
(setq-local doom-modeline-buffer-encoding
(unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                    '(coding-category-undecided coding-category-utf-8))
            (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)

(setq doom-modeline-minor-modes nil)
(setq doom-modeline-enable-word-count t) ; super nice in visual mode
 #+end_src



**** Other stuff

***** Line numbers

I literally cannot function without relative lines numbers
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

***** Buffer names

Why not take advantage of icons for the default buffer
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "â–º Doom"
+doom-dashboard-name "â–º Doom")

#+end_src


***** Async config tangle

courtesy of Tec once again, as literate config files get big and tangling is blocking by default
having a simple async version seems like a good idea

#+begin_src emacs-lisp

(defadvice! +literate-tangle-async-h ()
"A very simplified version of `+literate-tangle-h', but async."
:override #'+literate-tangle-h
(let ((default-directory doom-private-dir))
(async-shell-command
(format "emacs --batch --eval \"(progn \
(require 'org) (setq org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
+literate-config-file))))

#+end_src



***** Splash screen

re-occurring pain point as this is the first thing that you see when you open emacs. Finding both the right image at the right size and colour is difficult.
At the moment it is simple but I have bigger plans
 #+begin_src emacs-lisp

(defvar fancy-splash-image-template
(expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
"Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
`((:height 300 :min-height 50 :padding (0 . 2))
(:height 250 :min-height 42 :padding (2 . 4))
(:height 200 :min-height 35 :padding (3 . 3))
(:height 150 :min-height 28 :padding (3 . 3))
(:height 100 :min-height 20 :padding (2 . 2))
(:height 75  :min-height 15 :padding (2 . 1))
(:height 50  :min-height 10 :padding (1 . 0))
(:height 1   :min-height 0  :padding (0 . 0)))
"list of plists with the following properties
:height the height of the image
:min-height minimum `frame-height' for image
:padding `+doom-dashboard-banner-padding' (top . bottom) to apply
:template non-default template file
:file file to use instead of template")

(defvar fancy-splash-template-colours
'(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
"list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
(make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
(expand-file-name (concat (file-name-as-directory "theme-splashes")
            theme-name
            "-" (number-to-string height) ".svg")
    doom-cache-dir))

(defun fancy-splash-clear-cache ()
"Delete all cached fancy splash images"
(interactive)
(delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
(message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
"Read TEMPLATE and create an image if HEIGHT with colour substitutions as
described by `fancy-splash-template-colours' for the current theme"
(with-temp-buffer
(insert-file-contents template)
(re-search-forward "$height" nil t)
(replace-match (number-to-string height) nil nil)
(dolist (substitution fancy-splash-template-colours)
(goto-char (point-min))
(while (re-search-forward (car substitution) nil t)
(replace-match (doom-color (cdr substitution)) nil nil)))
(write-region nil nil
    (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
"Perform `fancy-splash-generate-image' in bulk"
(dolist (size fancy-splash-sizes)
(unless (plist-get size :file)
(fancy-splash-generate-image (or (plist-get size :template)
                        fancy-splash-image-template)
                    (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
(unless (file-exists-p (fancy-splash-filename
            (symbol-name doom-theme)
            (or height
                (plist-get (car fancy-splash-sizes) :height))))
(fancy-splash-generate-images)))

(defun get-appropriate-splash ()
(let ((height (frame-height)))
(cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
(let ((appropriate-image (get-appropriate-splash)))
(unless (and (equal appropriate-image fancy-splash-last-size)
    (equal doom-theme fancy-splash-last-theme)))
(unless (plist-get appropriate-image :file)
(ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
(setq fancy-splash-image
(or (plist-get appropriate-image :file)
(fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
(setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
(setq fancy-splash-last-size appropriate-image)
(setq fancy-splash-last-theme doom-theme)
(+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
 #+end_src


***** Full screen

The majority of screens that I work on are 1080p so having emacs full screen by default is nice for them.
Should I switch to higher resolution displays this will likely become system dependent.
#+begin_src emacs-lisp
;; auto fullscreen
(if (eq initial-window-system 'x)                 ; if started by emacs command or desktop file
    (toggle-frame-maximized)
  (toggle-frame-fullscreen))
#+end_src

* Packages
** Loading instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Whilst doom provides most of what you will need if you are a package developer or need to get the absolute latest thing due to features or instability
there is a nice and simple way of doing so:  the ~package!~ macro in  =packages.el=.
~doom sync~ will need to be run afterwards.
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src


*** From MEPLA/EPLA/emacsmirror

For ~a-thing~ do:
#+begin_src emacs-lisp
(package! a-thing)
#+end_src

*** From GIT

As a reminder for me, to install something from a git repo use ~:recipe~ and documentation
can be found [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! some-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If there isn't a ~PACKAGENAME.el~ or its in a weird place use ~:files~.
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_SRC

*** Disable defaults

You can get rid of the defaults:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src

You can overwrite the defaults
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

It should be noted that Doom will fill in the rest of ~:recipe~ so you don't have to!

You can even override with a specific branch:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src


** Tools


*** Very Large files

title is self explanatory. Why not chunk files?
#+begin_src emacs-lisp
;; (package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
;;   :pin "cc02f2533782d6b9b628cec7e2dcf25b2d05a27c" :disable t)
#+end_src
as it is something I use infrequently I don't want it to delay start up
#+begin_src emacs-lisp
;; (use-package! vlf-setup
;;   :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

*** Eros

#+begin_quote
 =:tools eval=
#+end_quote

Provides amazing inline evaluation of ~elisp~ using =gr= and =gR=.
Another gem from Tec's config is to make this look better
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "âŸ¹ ") ; default =>
#+end_src


*** Evil

#+begin_quote
=:editor evil=
#+end_quote

Doom's configuration of evil is reasonable and pragmatic.
However everyone has some personal preferences.
#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

*** Magit

TODO: handle automated setup
I have yet to find something I want to change about magit. Maybe magit delta can be put to use.
#+begin_src emacs-lisp

;; (after! magit
;;   (magit-delta-mode +1))


#+end_src

*** Company

I both love and hate company. It make emacs better than any vim plugin system, but is also
the thing that is most likely going to slow down my typing experience.

#+begin_src emacs-lisp
(after! company
  (setq company-minimum-prefix-length 2)
  (setq company-show-numbers t))
#+end_src

Also a good idea to improve memory:
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

**** LSP optimization

the following can help to see if its the language server or company that is slow.
Its almost always garbage collection though.
#+begin_src emacs-lisp
(setq company-idle-delay 0.01)
#+end_src

**** Plain text defaults

Having ~Ispell~ Enabled is really useful.

#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src

**** ESS

Nothing to put here currently. Look into ~company-dabbrev-code~

*   The rest

#+begin_src emacs-lisp

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/org/")



(setq projectile-indexing-method 'native)


(after! flycheck
(map! :leader
(:prefix-map ("c" . "code")
"x" flycheck-command-map)))


(setq evil-escape-excluded-major-modes '(neotree-mode treemacs-mode))
;; fancy splash


(setq +ligatureskextras-in-modes '(elisp-mode))
(setq +ligatures-in-modes '(not special-mode comint-mode eshell-mode term-mode vterm-mode Info-mode python-mode))

;; (setq forge-database-connector 'sqlite3)
(setq gc-cons-threshold 10000000)
(setq read-process-output-max (* 1024 1024)) ;; 1mb
;; (setq lsp-idle-delay 0.500)
(setq +ligatures-in-modes 'nil)
(setq +ligatures-extras-in-modes 'nil)
;; (setq shell-file-name "bash")
;; (setq shell-command-switch "-ic")
#+end_src


#+begin_src emacs-lisp
;; (after! mu4e
;;   (defvar mu4e-reindex-request-file "/tmp/mu_reindex_now"
;;     "Location of the reindex request, signaled by existance")
;;   (defvar mu4e-reindex-request-min-seperation 5.0
;;     "Don't refresh again until this many second have elapsed.
;; Prevents a series of redisplays from being called (when set to an appropriate value)")

;;   (defvar mu4e-reindex-request--file-watcher nil)
;;   (defvar mu4e-reindex-request--file-just-deleted nil)
;;   (defvar mu4e-reindex-request--last-time 0)

;;   (defun mu4e-reindex-request--add-watcher ()
;;     (setq mu4e-reindex-request--file-just-deleted nil)
;;     (setq mu4e-reindex-request--file-watcher
;;           (file-notify-add-watch mu4e-reindex-request-file
;;                                  '(change)
;;                                  #'mu4e-file-reindex-request)))

;;   (defadvice! mu4e-stop-watching-for-reindex-request ()
;;     :after #'mu4e~proc-kill
;;     (if mu4e-reindex-request--file-watcher
;;         (file-notify-rm-watch mu4e-reindex-request--file-watcher)))

;;   (defadvice! mu4e-watch-for-reindex-request ()
;;     :after #'mu4e~proc-start
;;     (mu4e-stop-watching-for-reindex-request)
;;     (when (file-exists-p mu4e-reindex-request-file)
;;       (delete-file mu4e-reindex-request-file))
;;     (mu4e-reindex-request--add-watcher))

;;   (defun mu4e-file-reindex-request (event)
;;     "Act based on the existance of `mu4e-reindex-request-file'"
;;     (if mu4e-reindex-request--file-just-deleted
;;         (mu4e-reindex-request--add-watcher)
;;       (when (equal (nth 1 event) 'created)
;;         (delete-file mu4e-reindex-request-file)
;;         (setq mu4e-reindex-request--file-just-deleted t)
;;         (mu4e-reindex-maybe t))))

;;   (defun mu4e-reindex-maybe (&optional new-request)
;;     "Run `mu4e~proc-index' if it's been more than
;; `mu4e-reindex-request-min-seperation'seconds since the last request,"
;;     (let ((time-since-last-request (- (float-time)
;;                                       mu4e-reindex-request--last-time)))
;;       (when new-request
;;         (setq mu4e-reindex-request--last-time (float-time)))
;;       (if (> time-since-last-request mu4e-reindex-request-min-seperation)
;;           (mu4e~proc-index nil t)
;;         (when new-request
;;           (run-at-time (* 1.1 mu4e-reindex-request-min-seperation) nil
;;                        #'mu4e-reindex-maybe))))))
;; (with-eval-after-load 'mu4e
;; (setq mu4e-context-policy 'pick-first)
;; (setq mu4e-compose-context-policy 'always-ask)

;; (setq mu4e-contexts
;;       (list
;;        (make-mu4e-context
;;     :name "iinet"
;;     :enter-func (lambda () (mu4e-message "Entering iinet context"))
;;     :leave-func (lambda () (mu4e-message "Leaving iinet context"))
;;     :match-func (lambda (msg)
;;               (when msg
;;             (mu4e-message-contact-field-matches
;;              msg '(:from :to :cc :bcc) "dbadams@iinet.net.au")))
;;     :vars '((user-mail-address . "dbadams@iinet.net.au")
;;         (user-full-name . "David Adams")
;;         (mu4e-sent-folder . "/iinet/Sent")
;;         (mu4e-drafts-folder . "/iinet/Drafts")
;;         (mu4e-trash-folder . "/iinet/Trash")
;;         (mu4e-refile-folder . "/iinet/Archives")
;;         ;; (smtpmail-queue-dir . "~/.email/gmail/queue/cur")
;;         (smtpmail-smtp-user . "dbadams@iinet.net.au")
;;         (smtpmail-starttls-credentials . (("dbadams@iinet.net.au" 587 nil nil)))
;;         (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
;;         (smtpmail-default-smtp-server . "smtp.iinet.net.au")
;;         (smtpmail-smtp-server . "smtp.iinet.net.au")
;;         (smtpmail-smtp-service . 587)
;;         (mu4e-sent-messages-behavior . sent)
;;         ;; (mu4e-maildir-shortcuts . ( ("/work/INBOX"    . ?i)
;;         ;;                 ("/work/Sent"     . ?s)
;;         ;;                 ("/work/Trash"    . ?t)
;;         ;;                 ("/work/Archives" . ?a)
;;         ;;                 ("/work/Drafts"   . ?d)
;;         ;;                 ))
;;         ))

;;        (make-mu4e-context
;;     :name "gmail"
;;     :enter-func (lambda () (mu4e-message "Entering gmail context"))
;;     :leave-func (lambda () (mu4e-message "Leaving gmail context"))
;;     :match-func (lambda (msg)
;;               (when msg
;;             (mu4e-message-contact-field-matches
;;              msg '(:from :to :cc :bcc) "davidbadams110@gmail.com")))
;;     :vars '((user-mail-address . "davidbadams110@gmail.com")
;;         (user-full-name . "David Adams")
;;                   (mu4e-drafts-folder  . "/dagmail/[Gmail]/Drafts")
;;                   (mu4e-sent-folder  . "/dagmail/[Gmail]/Sent Mail")
;;                   (mu4e-refile-folder  . "/dagmail/[Gmail]/All Mail")
;;                   (mu4e-trash-folder  . "/dagmail/[Gmail]/Trash")
;;         ;; (smtpmail-queue-dir . "~/.email/gmail/queue/cur")
;;         (smtpmail-smtp-user . "davidbadams110@gmail.com")
;;         (smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
;;         (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
;;         (smtpmail-default-smtp-server . "smtp.gmail.com")
;;         (smtpmail-smtp-server . "smtp.gmail.com")
;;         (smtpmail-smtp-service . 587)
;;         (mu4e-sent-messages-behavior . delete)
;;         ;; (mu4e-maildir-shortcuts . ( ("/gmail/INBOX"                        . ?i)
;;         ;;                 ("/gmail/[Gmail]/Messages envoy&AOk-s" . ?s)
;;         ;;                 ("/gmail/[Gmail]/Corbeille"            . ?t)
;;         ;;                 ("/gmail/[Gmail]/Tous les messages"    . ?a)
;;         ;;                 ("/gmail/[Gmail]/Brouillons"           . ?d)
;;         ;;                 ))
;;         )))))
#+end_src

#+begin_src emacs-lisp
;; (setq sendmail-program "/usr/bin/msmtp"
;;       send-mail-function #'smtpmail-send-it
;;       message-sendmail-f-is-evil t
;;       message-sendmail-extra-arguments '("--read-envelope-from"); , "--read-recipients")
;;       message-send-mail-function #'message-send-mail-with-sendmail)
#+end_src

#+begin_src python :tangle misc/mbsync-imapnotify.py :shebang "#!/usr/bin/env python3"
# from pathlib import Path
# import json
# import re
# import shutil
# import subprocess
# import sys
# import fnmatch

# mbsyncFile = Path("~/.mbsyncrc").expanduser()

# imapnotifyConfigFolder = Path("~/.config/imapnotify/").expanduser()
# imapnotifyConfigFolder.mkdir(exist_ok=True)
# imapnotifyConfigFilename = "notify.conf"

# imapnotifyDefault = {
#     "host": "",
#     "port": 993,
#     "tls": True,
#     "tlsOptions": {"rejectUnauthorized": True},
#     "onNewMail": "",
#     "onNewMailPost": "if mu index --lazy-check; then test -f /tmp/mu_reindex_now && rm /tmp/mu_reindex_now; else touch /tmp/mu_reindex_now; fi",
# }


# def stripQuotes(string):
#     if string[0] == '"' and string[-1] == '"':
#         return string[1:-1].replace('\\"', '"')


# mbsyncInotifyMapping = {
#     "Host": (str, "host"),
#     "Port": (int, "port"),
#     "User": (str, "username"),
#     "Password": (str, "password"),
#     "PassCmd": (stripQuotes, "passwordCmd"),
#     "Patterns": (str, "_patterns"),
# }

# oldAccounts = [d.name for d in imapnotifyConfigFolder.iterdir() if d.is_dir()]

# currentAccount = ""
# currentAccountData = {}

# successfulAdditions = []


# def processLine(line):
#     newAcc = re.match(r"^IMAPAccount ([^#]+)", line)

#     linecontent = re.sub(r"(^|[^\\])#.*", "", line).split(" ", 1)
#     if len(linecontent) != 2:
#         return

#     parameter, value = linecontent

#     if parameter == "IMAPAccount":
#         if currentAccountNumber > 0:
#             finaliseAccount()
#         newAccount(value)
#     elif parameter in mbsyncInotifyMapping.keys():
#         parser, key = mbsyncInotifyMapping[parameter]
#         currentAccountData[key] = parser(value)
#     elif parameter == "Channel":
#         currentAccountData["onNewMail"] = f"mbsync --pull --new {value}:'%s'"


# def newAccount(name):
#     global currentAccountNumber
#     global currentAccount
#     global currentAccountData
#     currentAccountNumber += 1
#     currentAccount = name
#     currentAccountData = {}
#     print(f"\n\033[1;32m{currentAccountNumber}\033[0;32m - {name}\033[0;37m")


# def accountToFoldername(name):
#     return re.sub(r"[^A-Za-z0-9]", "", name)


# def finaliseAccount():
#     if currentAccountNumber == 0:
#         return

#     global currentAccountData
#     try:
#         currentAccountData["boxes"] = getMailBoxes(currentAccount)
#     except subprocess.CalledProcessError as e:
#         print(
#             f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
#             + f"`{' '.join(e.cmd)}' returned code {e.returncode}\033[0;37m"
#         )
#         return
#     except subprocess.TimeoutExpired as e:
#         print(
#             f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
#             + f"`{' '.join(e.cmd)}' timed out after {e.timeout:.2f} seconds\033[0;37m"
#         )
#         return

#     if "_patterns" in currentAccountData:
#         currentAccountData["boxes"] = applyPatternFilter(
#             currentAccountData["_patterns"], currentAccountData["boxes"]
#         )

#     # strip not-to-be-exported data
#     currentAccountData = {
#         k: currentAccountData[k] for k in currentAccountData if k[0] != "_"
#     }

#     parametersSet = currentAccountData.keys()
#     currentAccountData = {**imapnotifyDefault, **currentAccountData}
#     for key, val in currentAccountData.items():
#         valColor = "\033[0;33m" if key in parametersSet else "\033[0;37m"
#         print(f"  \033[1;37m{key:<13} {valColor}{val}\033[0;37m")

#     if (
#             len(currentAccountData["boxes"]) > 15
#             and "@gmail.com" in currentAccountData["username"]
#     ):
#         print(
#             "  \033[1;31mWarning:\033[0;31m Gmail raises an error when more than"
#             + "\033[1;31m15\033[0;31m simultanious connections are attempted."
#             + "\n           You are attempting to monitor "
#             + f"\033[1;31m{len(currentAccountData['boxes'])}\033[0;31m mailboxes.\033[0;37m"
#         )

#     configFile = (
#         imapnotifyConfigFolder
#         / accountToFoldername(currentAccount)
#         / imapnotifyConfigFilename
#     )
#     configFile.parent.mkdir(exist_ok=True)

#     json.dump(currentAccountData, open(configFile, "w"), indent=2)
#     print(f" \033[0;35mConfig generated and saved to {configFile}\033[0;37m")

#     global successfulAdditions
#     successfulAdditions.append(accountToFoldername(currentAccount))


# def getMailBoxes(account):
#     boxes = subprocess.run(
#         ["mbsync", "--list", account], check=True, stdout=subprocess.PIPE, timeout=10.0
#     )
#     return boxes.stdout.decode("utf-8").strip().split("\n")


# def applyPatternFilter(pattern, mailboxes):
#     patternRegexs = getPatternRegexes(pattern)
#     return [m for m in mailboxes if testPatternRegexs(patternRegexs, m)]


# def getPatternRegexes(pattern):
#     def addGlob(b):
#         blobs.append(b.replace('\\"', '"'))
#         return ""

#     blobs = []
#     pattern = re.sub(r' ?"([^"]+)"', lambda m: addGlob(m.groups()[0]), pattern)
#     blobs.extend(pattern.split(" "))
#     blobs = [
#         (-1, fnmatch.translate(b[1::])) if b[0] == "!" else (1, fnmatch.translate(b))
#         for b in blobs
#     ]
#     return blobs


# def testPatternRegexs(regexCond, case):
#     for factor, regex in regexCond:
#         if factor * bool(re.match(regex, case)) < 0:
#             return False
#     return True


# def processSystemdServices():
#     keptAccounts = [acc for acc in successfulAdditions if acc in oldAccounts]
#     freshAccounts = [acc for acc in successfulAdditions if acc not in oldAccounts]
#     staleAccounts = [acc for acc in oldAccounts if acc not in successfulAdditions]

#     if keptAccounts:
#         print(f"\033[1;34m{len(keptAccounts)}\033[0;34m kept accounts:\033[0;37m")
#         restartAccountSystemdServices(keptAccounts)

#     if freshAccounts:
#         print(f"\033[1;32m{len(freshAccounts)}\033[0;32m new accounts:\033[0;37m")
#         enableAccountSystemdServices(freshAccounts)
#     else:
#         print(f"\033[0;32mNo new accounts.\033[0;37m")

#     notActuallyEnabledAccounts = [
#         acc for acc in successfulAdditions if not getAccountServiceState(acc)["enabled"]
#     ]
#     if notActuallyEnabledAccounts:
#         print(
#             f"\033[1;32m{len(notActuallyEnabledAccounts)}\033[0;32m accounts need re-enabling:\033[0;37m"
#         )
#         enableAccountSystemdServices(notActuallyEnabledAccounts)

#     if staleAccounts:
#         print(f"\033[1;33m{len(staleAccounts)}\033[0;33m removed accounts:\033[0;37m")
#         disableAccountSystemdServices(staleAccounts)
#     else:
#         print(f"\033[0;33mNo removed accounts.\033[0;37m")


# def enableAccountSystemdServices(accounts):
#     for account in accounts:
#         print(f" \033[0;32m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
#         if setSystemdServiceState(
#                 "enable", f"goimapnotify@{accountToFoldername(account)}.service"
#         ):
#             print("\033[1;32m enabled")


# def disableAccountSystemdServices(accounts):
#     for account in accounts:
#         print(f" \033[0;33m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
#         if setSystemdServiceState(
#                 "disable", f"goimapnotify@{accountToFoldername(account)}.service"
#         ):
#             print("\033[1;33m disabled")


# def restartAccountSystemdServices(accounts):
#     for account in accounts:
#         print(f" \033[0;34m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
#         if setSystemdServiceState(
#                 "restart", f"goimapnotify@{accountToFoldername(account)}.service"
#         ):
#             print("\033[1;34m restarted")


# def setSystemdServiceState(state, service):
#     try:
#         enabler = subprocess.run(
#             ["systemctl", "--user", state, service, "--now"],
#             check=True,
#             stderr=subprocess.DEVNULL,
#             timeout=5.0,
#         )
#         return True
#     except subprocess.CalledProcessError as e:
#         print(
#             f" \033[1;31mfailed\033[0;31m to {state}, `{' '.join(e.cmd)}'"
#             + f"returned code {e.returncode}\033[0;37m"
#         )
#     except subprocess.TimeoutExpired as e:
#         print(f" \033[1;31mtimed out after {e.timeout:.2f} seconds\033[0;37m")
#         return False


# def getAccountServiceState(account):
#     return {
#         state: bool(
#             1
#             - subprocess.run(
#                 [
#                     "systemctl",
#                     "--user",
#                     f"is-{state}",
#                     "--quiet",
#                     f"goimapnotify@{accountToFoldername(account)}.service",
#                 ],
#                 stderr=subprocess.DEVNULL,
#             ).returncode
#         )
#         for state in ("enabled", "active", "failing")
#     }


# def getAccountServiceStates(accounts):
#     for account in accounts:
#         enabled, active, failing = getAccountServiceState(account).values()
#         print(f"  - \033[1;37m{account:<18}\033[0;37m ", end="", flush=True)
#         if not enabled:
#             print("\033[1;33mdisabled\033[0;37m")
#         elif active:
#             print("\033[1;32mactive\033[0;37m")
#         elif failing:
#             print("\033[1;31mfailing\033[0;37m")
#         else:
#             print("\033[1;35min an unrecognised state\033[0;37m")


# if len(sys.argv) > 1:
#     if sys.argv[1]   in ["-e", "--enable"]:
#         enableAccountSystemdServices(oldAccounts)
#         exit()
#     elif sys.argv[1] in ["-d", "--disable"]:
#         disableAccountSystemdServices(oldAccounts)
#         exit()
#     elif sys.argv[1] in ["-r", "--restart"]:
#         restartAccountSystemdServices(oldAccounts)
#         exit()
#     elif sys.argv[1] in ["-s", "--status"]:
#         getAccountServiceStates(oldAccounts)
#         exit()
#     elif sys.argv[1] in ["-h", "--help"]:
#         print("""\033[1;37mMbsync to IMAP Notify config generator.\033[0;37m

# Usage: mbsync-imapnotify [options]

# Options:
#     -e, --enable       enable all services
#     -d, --disable      disable all services
#     -r, --restart      restart all services
#     -s, --status       fetch the status for all services
#     -h, --help         show this help
# """, end='')
#         exit()
#     else:
#         print(f"\033[0;31mFlag {sys.argv[1]} not recognised, try --help\033[0;37m")
#         exit()


# mbsyncData = open(mbsyncFile, "r").read()

# currentAccountNumber = 0

# totalAccounts = len(re.findall(r"^IMAPAccount", mbsyncData, re.M))


# def main():
#     print("\033[1;34m:: MbSync to Go IMAP notify config file creator ::\033[0;37m")

#     shutil.rmtree(imapnotifyConfigFolder)
#     imapnotifyConfigFolder.mkdir(exist_ok=False)
#     print("\033[1;30mImap Notify config dir purged\033[0;37m")

#     print(f"Identified \033[1;32m{totalAccounts}\033[0;32m accounts.\033[0;37m")

#     for line in mbsyncData.split("\n"):
#         processLine(line)

#     finaliseAccount()

#     print(
#         f"\nConfig files generated for \033[1;36m{len(successfulAdditions)}\033[0;36m"
#         + f" out of \033[1;36m{totalAccounts}\033[0;37m accounts.\n"
#     )

#     processSystemdServices()


# if __name__ == "__main__":
#     main()
#+end_src

#+begin_src systemd :no-tangle ~/.config/systemd/user/goimapnotify@.service
# [Unit]
# Description=IMAP notifier using IDLE, golang version.
# ConditionPathExists=%h/.config/imapnotify/%I/notify.conf
# After=network.target

# [Service]
# ExecStart=%h/.local/bin/goimapnotify -conf %h/.config/imapnotify/%I/notify.conf
# Restart=always
# RestartSec=30

# [Install]
# WantedBy=default.target
#+end_src

#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync.timer" "no")
# [Unit]
# Description=call mbsync on all accounts every 5 minutes
# ConditionPathExists=%h/.mbsyncrc

# [Timer]
# OnBootSec=5m
# OnUnitInactiveSec=5m

# [Install]
# WantedBy=default.target
#+end_src

#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync.service" "no")
# [Unit]
# Description=mbsync service, sync all mail
# Documentation=man:mbsync(1)
# ConditionPathExists=%h/.mbsyncrc

# [Service]
# Type=oneshot
# ExecStart=/usr/bin/mbsync -c %h/.mbsyncrc --all

# [Install]
# WantedBy=mail.target
#+end_src
#+begin_src emacs-lisp

;; (setq mu4e-headers-fields
;;       '((:flags . 6)
;;         (:account-stripe . 2)
;;         (:from-or-to . 25)
;;         (:folder . 10)
;;         (:recipnum . 2)
;;         (:subject . 80)
;;         (:human-date . 8))
;;       +mu4e-min-header-frame-width 142
;;       mu4e-headers-date-format "%d/%m/%y"
;;       mu4e-headers-time-format "?? %H:%M"
;;       mu4e-headers-results-limit 1000
;;       mu4e-index-cleanup t)

;; (add-to-list 'mu4e-bookmarks
;;              '(:name "Yesterday's messages" :query "date:2d..1d" :key ?y) t)

;; (defvar +mu4e-header--folder-colors nil)
;; (appendq! mu4e-header-info-custom
;;           '((:folder .
;;              (:name "Folder" :shortname "Folder" :help "Lowest level folder" :function
;;               (lambda (msg)
;;                 (+mu4e-colorize-str
;;                  (replace-regexp-in-string "\\`.*/" "" (mu4e-message-field msg :maildir))
;;                  '+mu4e-header--folder-colors))))))
#+end_src



#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.
(package! gitconfig-mode
	  :recipe (:host github :repo "magit/git-modes"
			 :files ("gitconfig-mode.el")))
(package! gitignore-mode
	  :recipe (:host github :repo "magit/git-modes"
			 :files ("gitignore-mode.el")))

(unpin! magit forge)


(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")

(use-package! systemd
  :defer t)


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)
#+end_src
