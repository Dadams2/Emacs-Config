#+title: Doom Emacs Configuration
#+subtitle: Taming the Tyranny of Text Transformation
#+author: Dadams
#+startup: content

* Table of Contents :TOC:
- [[#preamble][Preamble]]
- [[#the-simple-stuff][The simple stuff]]
  - [[#work-config][Work config]]
  - [[#personal-info][Personal info]]
  - [[#default-settings][Default settings]]
  -  [[#doom-config][Doom Config]]
  - [[#fixing-bugs][Fixing bugs]]
  - [[#other-stuff][Other stuff]]
- [[#packages][Packages]]
  - [[#loading-instructions][Loading instructions]]
  - [[#convenience][Convenience]]
  - [[#tools][Tools]]
  - [[#visuals][Visuals]]
  - [[#file-types][File Types]]
- [[#applications][Applications]]
  - [[#mail][Mail]]
  - [[#rssnewsfeed-reader][RSS/Newsfeed Reader]]
- [[#languages][Languages]]
  - [[#org][Org]]
  - [[#python][Python]]
  - [[#graphviz][Graphviz]]
  - [[#regex][Regex]]
-   [[#the-rest][The rest]]
- [[#org-jira-things][Org Jira things]]
- [[#other-packages][Other packages]]

* Preamble

I don't really know what I am doing, but it seems fun. If you want an actual representation of something good check out [[https://tecosaur.github.io/emacs-config/config.html][Tecosaurs Config]].

A note to the unweary adventurer. At no point in this config should you put the line:
#+begin_src org :tangle no
#+ +begin_src emacs-lisp tangle: "yes"
#+end_src
Org assumes the =tangle: yes= by default for all source blocks but if you manually put it there this breaks that assumption
and no source blocks will be tangled


* The simple stuff

apparently this makes things run faster (I found it [[https://nullprogram.com/blog/2016/12/22/][here]])
#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src


#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/usr/bin/env bash
#+end_src

** Work config

Sometimes I want things to be slightly different if I am at work
#+begin_src emacs-lisp
(defmacro da/at-work ()
  "Return t if current user is davida, nil otherwise."
  `(string-equal (user-login-name) "davida"))

(defun da/sub-work (home work)
  "Return HOME if the current user is not davida, WORK otherwise."
  (if (da/at-work) work home))
#+end_src

** Personal info

From ~GPG~ to ~git~ to email clients and snippets, the following seems kinda important to have around
#+begin_src emacs-lisp
(setq user-full-name "David Adams"
      user-mail-address "dbadams@iinet.net.au")
#+end_src


*** GPG
#+begin_src emacs-lisp
(setq auth-sources (da/sub-work '("~/.authinfo.gpg") '("~/.authinfo"))
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src
** Default settings

*** Common settings
Following in Tec's footsteps I somehow stumbled upon [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]] which gave some inspiration on better default settings

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                    ; its rubbish bin not trash
 window-combination-resize t                    ; take all new space
 x-stretch-cursor t                             ; deal with glyphs
 ;; enable-local-variables t                    ; I want to be able to use dir-locals
 ;; global-auto-revert-mode t                   ; reload files on disk
 )


(setq
 undo-limit 80000000
 evil-want-fine-undo t                          ; make undo limit bigger
 auto-save-default t                            ; help with the b-s
 truncate-string-ellipsis "…"                   ; is nicer
 password-cache-expiry nil
 compilation-scroll-output t                    ; warnings annoy me
 )

(unless (string-match-p "^Power N/A" (battery)) ; On laptops...
  (display-battery-mode 1))                     ; it's nice to know how much power you have

;; (global-subword-mode 1)                         ; Iterate through CamelCase words
#+end_src

***  Frame sizing

Creating a new full-size window each time we want a new frame does not seem ideal. Especially considering window managers
make it easy to snap windows into the correct place

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src

whilst this is not specifically needed for my setup on WM's, I do have to use normal desktop envs so this is useful.


***  Window Splitting

I always want new windows to be to the right

#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src
and when I do I would like to be promoted for what buffer to switch to


#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

being able to rotate window layouts is nice
#+begin_src elisp
(map! :map evil-window-map
      "SPC" #'rotate-layout)
#+end_src


*** Window switching
doom uses ace window for quick navigation between multiple windows.
By default numbers are used. I would rather use the home row
Simply don't' add src_elisp{+numbers} to src_elisp{ui: window-select}
#+begin_src emacs-lisp
;; (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
;; (custom-set-faces!
;;   '(aw-leading-char-face
;;     :foreground "white" :background "red"
;;     :weight bold :height 2.5 :box (:line-width 5 :color "red")))
#+end_src
TODO: consider a better face for it
*** Embark for window switching
#+begin_src emacs-lisp
(after! embark
  (eval-when-compile
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn)))))))

  (define-key embark-file-map     (kbd "o") (my/embark-ace-action find-file))
  (define-key embark-buffer-map   (kbd "o") (my/embark-ace-action switch-to-buffer))
  (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump))
  )
#+end_src

**  Doom Config

*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
You have probable seen a ~how to install~ section at the top of a bunch of emacs pages. Doom has it so that you remove a comment
and that's it. There are also extra features that can be added to some of the modules with a =+<somtehing>=

#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no

;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom!  :input
        <<doom-input>>

        :completion
        <<doom-completion>>

        :ui
        <<doom-ui>>

        :editor
        <<doom-editor>>

        :term
        <<doom-term>>

        :checkers
        <<doom-checkers>>

        :tools
        <<doom-tools>>

        :os
        <<doom-os>>

        :lang
        <<doom-lang>>

        :email
        <<doom-email>>

        :app
        <<doom-app>>

        :config
        <<doom-config>>
        ) ;lol don't forget this closing brace like I did
#+end_src

**** Config's config

If you don't know what a literate configuration is, welcome! You are reading one.
Doom has some rather nice defaults for literate src_elisp{:config}
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Completion

#+name: doom-completion
#+begin_src emacs-lisp
(company            ; the ultimate code completion backend
 +childframe)       ; ... when the children are actually better
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;;(ivy
;; +icons           ; a search engine for love and life
;;)
(vertico +icons)    ; search endine for the future
#+end_src

**** General UI

Some are doom specific whilst others are nice quality of life improvements

#+name: doom-ui
#+begin_src emacs-lisp
;;deft                 ; notational velocity for Emacs
doom                   ; what makes DOOM look the way it does
doom-dashboard         ; a nifty splash screen for Emacs
;;doom-quit              ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)       ; 🙂
hl-todo                ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/
;;hydra                ; quick documentation for related commands
;;indent-guides        ; highlighted indent columns
(ligatures +extra)     ; ligatures and symbols to make your code pretty again
minimap                ; show a map of the code on the side
modeline               ; snazzy, Atom-inspired modeline, plus API
nav-flash              ; blink cursor line after big
;;neotree              ; a project drawer, like NERDTree for vim
ophints                ; highlight the region an operation acts on
(popup +defaults +all) ; tame sudden yet inevitable temporary windows
tabs                   ; a tab bar for Emacs and prettyer tabs
treemacs               ; a project drawer, like neotree but cooler
unicode                ; extended unicode support for various languages
vc-gutter              ; vcs diff in the fringe
vi-tilde-fringe        ; fringe tildes to mark beyond EOB
window-select          ; visually switch windows
workspaces             ; tab emulation, persistence & separate workspaces
zen                    ; distraction-free coding or writing
#+end_src

**** Editor things

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)     ; come to the dark side, we have cookies
file-templates         ; auto-snippets for empty files
fold                   ; (nigh) universal code folding
(format +onsave)       ; automated
;;god                  ; run Emacs commands without modifier keys
;;lispy                ; vim for lisp, for people who don't like vim
multiple-cursors       ; editing in many places at once
;;objed                ; text object editing for the innocent
;;parinfer             ; turn lisp into python, sort of
;;rotate-text          ; cycle region at point between text candidates
snippets               ; my elves. They type so I don't have to
;;word-wrap            ; soft wrapping with language-aware indent

:emacs
(dired +icons)         ; making dired pretty [functional]
electric               ; smarter, keyword-based electric-indent
(ibuffer +icons)       ; interactive buffer management
undo                   ; persistent, smarter undo for your inevitable mistakes
vc                     ; version-control and Emacs, sitting in a tree
#+end_src

**** Terminals

whilst vterm is the best terminal emulator inside emacs currently, it is the most painful thing to compile (with
                                                                                                            the exception of maybe pdftools). As such having alternatives can be useful

#+name: doom-term
#+begin_src emacs-lisp
eshell            ; the elisp shell that works everywhere
;;shell           ; simple shell REPL for Emacs
;;term            ; basic terminal emulator for Emacs
vterm             ; the best terminal emulation in Emacs
#+end_src

**** Checkers

not much to be said. spell-fu seems good but the interfaces are not as nice
grammar would be much better if it offered suggestions on how to improve things (well specifically writegood mode)
#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
(:if (executable-find "aspell") (spell +flyspell +aspell +everywhere)) ; tasing you for misspelling mispelling
grammar           ; tasing grammar mistake every you make
#+end_src


**** Other stuff

despite the name herein lies some of the things that make emacs worth using.

#+name: doom-tools
#+begin_src emacs-lisp
ansible
;;biblio        ; Writes a PhD for you (citation needed)
(debugger +lsp) ; FIXME stepping through code, to help you add bugs
;;direnv        ; be direct about your environment
;;docker        ; port everything to containers
editorconfig    ; let someone else argue about tabs vs spaces
;;ein           ; tame Jupyter notebooks with emacs
(eval +overlay) ; run code, run (also, repls)
;;gist          ; interacting with github gists
lookup          ; navigate your code and its documentation
(lsp +elgot)    ; M-x vscode
;;macos         ; MacOS-specific commands
(magit +forge)  ; a git porcelain for Emacs
make            ; run make tasks from Emacs
;;pass          ; password manager for nerds
pdf             ; pdf enhancements
;;prodigy       ; FIXME managing external services & code builders
rgb             ; creating color strings
;;taskrunner    ; taskrunner for all your projects
;;terraform     ; infrastructure as code
;;tmux          ; an API for interacting with tmux
tree-sitter     ; syntax and parsing, sitting in a tree...
upload          ; map local to remote projects via ssh/ftp
#+end_src
#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)  ; improve compatibility with macOS
tty                 ; improve the terminal Emacs experience
#+end_src


**** Languages

#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
(cc +lsp)           ; C > C++ == 1
;;clojure           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .NET, and mono shenanigans
;;data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;dhall
;;elixir            ; erlang done right
;;elm               ; care for a cup of TEA?
emacs-lisp          ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
(fortran +lsp)      ; in FORTRAN, GOD is REAL (unless declared INTEGER)
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(graphql +lsp)    ; Give queries a REST
(haskell)    ; a language that's lazier than I am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
(json
 +lsp
 +tree-sitter)      ; At least it ain't XML
(java
 ;; +lsp
 +tree-sitter)      ; the poster child for carpal tunnel syndrome
(javascript +lsp)   ; all(hope(abandon(ye(who(enter(here))))))
(julia +lsp)        ; a better, faster MATLAB
;;kotlin            ; a better, slicker Java(Script)
latex               ; writing papers in Emacs has never been so fun
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
;;lua               ; one-based indices? one-based indices
(markdown +grip)    ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
;;nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org
 +pretty
 +pandoc
 +present
 +roam2
 +gnuplot
 +dragndrop
 +contacts
 +jupyter)          ; organize your plain life in plain text
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
(python
 +lsp
 +pyright
 ;; +conda          ; micromamba is better :D
 +cython)           ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rest              ; Emacs as a REST client
;;rst               ; ReST in peace
;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;(scheme +guile)   ; a fully conniving family of lisps
(sh +lsp)           ; she sells {ba,z,fi}sh shells on the C xor
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
web                 ; the tubes
(yaml +lsp)         ; JSON, but readable
;;zig               ; C, but simpler
#+end_src


**** Bring it all in

A constant work in progress. But trying to understand it does teach you a bunch.

#+name: doom-email
#+begin_src emacs-lisp
(:if (executable-find "mu") (mu4e +gmail +org))
;;notmuch
;;(wanderlust +gmail)
#+end_src

there are other things to consider as well
#+name: doom-app
#+begin_src emacs-lisp
;;calendar          ; A dated approach to timetabling
;;emms              ; Multimedia in Emacs is music to my ears
everywhere          ; *leave* Emacs!? You must be joking
irc                 ; how neckbeards socialize
(rss +org)          ; emacs as an RSS reader
;;twitter           ; twitter client https://twitter.com/vnought
#+end_src


**** Input

Whilst I could probably do japanese it would be a struggle so lets not
TODO: due to a bug in async tangle we don't include this
#+begin_src emacs-lisp :tangle no
;;bidi                       ; (tfel ot) thgir etirw uoy gnipleh
;;chinese
;;japanese
;;layout                     ; auie,ctsrnm is the superior home row
#+end_src

*** General Visual

**** Fonts

I am a big fan of 'Fira Code'. Font sizes do need some fiddling to get it all right.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Fira Code" :size 16)
      doom-big-font (font-spec :family "Fira Code" :size 24)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 24)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light)
      )
#+end_src

*jlhjjjah**** Missing Fonts

Warning about missing fonts is a bit of a problem especially if you are coming to a new system.
The following code (once again shamelessly ripped from Tec) makes it slightly more nice.
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts      '("Fira Code*" "Overpass" "JuliaMono" "IBM Plex Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts()>>
#+end_src
***** Fixing icons

Some icons such as       (should see a windows icon, up down arrows a clock and a calendar not rain clouds a rain drop or stars) can appear to be incorrect depending on what font doom uses for unicode rendering.
This can make things difficult if you are working on something that renders them differently.
#+begin_src emacs-lisp
(setq doom-unicode-font (font-spec :family "Fira Code Nerd Font"))
#+end_src

**** Theme and modeline

I like the softer look of Nord and use it in a number of other places. There are some disadvantages like weird comments
but overall its nice.

#+begin_src emacs-lisp
(setq doom-theme (da/sub-work 'doom-nord 'doom-vibrant))
#+end_src

I use linux on all my systems so I don't need to be told that =LF UTF-8= is my file encoding all the time
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

there are also a few other nice things I like
#+begin_src elisp
(setq doom-modeline-minor-modes nil)
(setq doom-modeline-enable-word-count t) ; super nice in visual mode
(setq doom-modeline-persp-name t) ; I want to know where I am
#+end_src
** Fixing bugs

in =mu= > 1.8 there is a problem with dooms default popup rules. Lets fix this
#+begin_src emacs-lisp
(set-popup-rule! "^\\*mu4e-\\(main\\|headers\\)\\*" :ignore t)
#+end_src




** Other stuff
*** Allow babel execution in CLI actions
In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

*** Line numbers

I literally cannot function without relative lines numbers
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src
*** Bookmarks
I like having access to bookmarks so lets save them in sane places and have a keybinding

#+begin_src emacs-lisp
(setq bookmark-default-file "~/.doom.d/bookmarks") ; I like being able to store my bookmarks properly

(map! :leader
      (:prefix-map ("b" . "buffer")
                   "C-s" 'bookmark-save))
#+end_src
*** Buffer names

Why not take advantage of icons for the default buffer
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom")

#+end_src

*** Splash screen

re-occurring pain point as this is the first thing that you see when you open emacs. Finding both the right image at the right size and colour is difficult.
At the moment it is simple but I have bigger plans

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/blackhole-lines.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")
(defvar fancy-splash-image-nil
  (expand-file-name "misc/splash-images/transparent-pixel.png" doom-private-dir)
  "An image to use at minimum size, usually a transparent pixel")

(setq fancy-splash-sizes
      `((:height 700 :min-height 70 :padding (0 . 2) :template ,(expand-file-name "misc/splash-images/blackhole-lines-0.svg" doom-private-dir))
        (:height 500 :min-height 50 :padding (1 . 2) :template ,(expand-file-name "misc/splash-images/blackhole-lines-0.svg" doom-private-dir))
        (:height 440 :min-height 42 :padding (1 . 4) :template ,(expand-file-name "misc/splash-images/blackhole-lines-0.svg" doom-private-dir))
        (:height 400 :min-height 38 :padding (1 . 4) :template ,(expand-file-name "misc/splash-images/blackhole-lines-1.svg" doom-private-dir))
        (:height 350 :min-height 36 :padding (1 . 3) :template ,(expand-file-name "misc/splash-images/blackhole-lines-2.svg" doom-private-dir))
        (:height 300 :min-height 34 :padding (1 . 3) :template ,(expand-file-name "misc/splash-images/blackhole-lines-3.svg" doom-private-dir))
        (:height 250 :min-height 32 :padding (1 . 2) :template ,(expand-file-name "misc/splash-images/blackhole-lines-4.svg" doom-private-dir))
        (:height 200 :min-height 30 :padding (1 . 2) :template ,(expand-file-name "misc/splash-images/blackhole-lines-5.svg" doom-private-dir))
        (:height 100 :min-height 24 :padding (1 . 2) :template ,(expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir))
        (:height 0   :min-height 0  :padding (0 . 0) :file ,fancy-splash-image-nil)))
;; "list of plists with the following properties
;; :height the height of the image
;; :min-height minimum `frame-height' for image
;; :padding `+doom-dashboard-banner-padding' to apply
;; :template non-default template file
;; :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . warning) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :file)
                                       (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src
*** Systemd daemon

for a lot of things it makes sense to run emacs as a daemon. Especially mail.
#+name: emacsclient service
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
Environment=COLORTERM=truecolor
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

which is then enabled by
#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

So to enable =mu4e= when actually running the daemon. Unfortunate that =circle= also cannot be started at this time.
Also make sure to switch to the dashboard.

#+name: daemon initialisation
#+begin_src emacs-lisp (if not((executable-find "mu")) ":tangle no")
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (when (+mu4e-lock-available t)
      (mu4e--start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft\\|\\*stdin\\|emacs-everywhere" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src


*** Full screen

The majority of screens that I work on are 1080p so having emacs full screen by default is nice for them.
Should I switch to higher resolution displays this will likely become system dependent.
#+begin_src emacs-lisp
;; auto fullscreen
;; (if (eq initial-window-system 'x)                 ; if started by emacs command or desktop file
;;     (toggle-frame-maximized)
;;   (toggle-frame-fullscreen))
#+end_src
#TODO: make this work with wayland


*** Dashboard quick actions

There are only a few things I do on the dashboard. So why not make them quicker and save keystrokes

#+begin_src emacs-lisp
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Open Org Agenda" :ng "a" #'org-agenda
        :desc "Find file" :ng "f" #'find-file
        :desc "Recent files" :ng "r" #'consult-recent-file
        :desc "Config dir" :ng "C" #'doom/open-private-config
        :desc "Open config.org" :ng "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ng "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ng "n" #'org-roam-node-find
        :desc "Switch buffer" :ng "b" #'+vertico/switch-workspace-buffer
        :desc "Open Vterm" :ng "v" #'+vterm/here
        :desc "Open Elfeed" :ng "l" #'elfeed
        :desc "Switch buffers (all)" :ng "<" #'consult-buffer
        :desc "IBuffer" :ng "i" #'ibuffer
        :desc "Open Project" :ng "p" #'projectile-switch-project
        :desc "Open Mail" :ng "m" #'mu4e
        :desc "Set theme" :ng "t" #'consult-theme
        :desc "Org Capture" :ng "x" #'org-capture
        :desc "Quit" :ng "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ng "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

leader for =d= is currently unbound so why not?
#+begin_src emacs-lisp
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src
*** Emacs Client Wrapper
I do make use of emacs as a terminal emulator from time to time.

By having this as a script instead of aliases we get a few advantages:
+ accepting stdin by putting in a temp file
+ guessing that =tty= is a good idea when ~$DISPLAY~ is unset
+ makes =emacsclient= instances non blocking

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
case "$1" in
-t | -nw | --tty)
force_tty=true
shift ;;
-w | --wait)
force_wait=true
shift ;;
-m | --mode)
stdin_mode=" ($2-mode)"
shift 2 ;;
-h | --help)
echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
exit 0 ;;
--*=*)
set -- "$@" "${1%%=*}" "${1#*=}"
shift ;;
,*)
if [ "$#" = 0 ]; then
break; fi
args+=("$1")
shift ;;
esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
unset 'args[-1]'
TMP="$(mktemp /tmp/emacsstdin-XXX)"
cat > "$TMP"
args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
# detect terminals with sneaky 24-bit support
if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
&& [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
termstub="${TERM%%-*}"; else
termstub="${TERM#*-}"; fi
if infocmp "$termstub-direct" >/dev/null 2>&1; then
TERM="$termstub-direct"; else
TERM="xterm-direct"; fi # should be fairly safe
fi
emacsclient --tty -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
else
if ! $force_wait; then
args+=(--no-wait); fi
emacsclient -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
fi
#+end_src

Now, to set an alias to use =e= with magit, and then for maximum laziness we can
set aliases for the terminal-forced variants.
#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src

*** Setup Script

Doom doesn't always install everything I need so there are a few things to bring in
#+name: run-setup
#+begin_src emacs-lisp :tangle no
;; (if (file-exists-p "setup.sh")
;;     (if (string-empty-p (string-trim (with-temp-buffer (insert-file-contents "setup.sh") (buffer-string)) "#!/usr/bin/env bash"))
;;         (message ";; Setup script is empty")
;;       (message ";; Detected content in the setup script")
;;       (pp-to-string
;;        `(unless noninteractive
;;           (defun +config-run-setup ()
;;             (when (yes-or-no-p (format "%s The setup script has content. Check and run the script?"
;;                                        (propertize "Warning!" 'face '(bold warning))))
;;               (find-file (expand-file-name "setup.sh" doom-private-dir))
;;               (when (yes-or-no-p "Would you like to run this script?")
;;                 (async-shell-command "./setup.sh"))))
;;           (add-hook! 'doom-init-ui-hook
;;             (run-at-time nil nil #'+config-run-setup)))))
;;   (message ";; setup.sh did not exist during tangle. Tangle again.")
;;   (pp-to-string
;;    `(unless noninteractive
;;       (add-hook! 'doom-init-ui-hook #'+literate-tangle-async-h))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
;; <<run-setup()>>
#+end_src
* Packages
** Loading instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Whilst doom provides most of what you will need if you are a package developer or need to get the absolute latest thing due to features or instability
there is a nice and simple way of doing so:  the ~package!~ macro in  =packages.el=.
~doom sync~ will need to be run afterwards.
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src


*** From MEPLA/EPLA/emacsmirror

For ~a-thing~ do:
#+begin_src emacs-lisp
(package! a-thing)
#+end_src

*** From GIT

As a reminder for me, to install something from a git repo use ~:recipe~ and documentation
can be found [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! some-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If there isn't a ~PACKAGENAME.el~ or its in a weird place use ~:files~.
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_SRC

*** Disable defaults

You can get rid of the defaults:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src

You can overwrite the defaults
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

It should be noted that Doom will fill in the rest of ~:recipe~ so you don't have to!

You can even override with a specific branch:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src


** Convenience

*** Avy

Apparently this is not enabled by default and I like going to multiple places
#+begin_src emacs-lisp
(setq avy-all-windows 'all-frames)
#+end_src

*** Evil-escape

Evil escape is disabled in ~vterm-mode~ by default. I dislike this so I will keep
all the defaults excepting it.
#+begin_src emacs-lisp
(setq evil-escape-excluded-major-modes '(neotree-mode treemacs-mode))
#+end_src

*** Ligatures


Ligature's are still an issue for me. Especially python. So I have done a bit of a blanket ignore
till I figure out what I want
#+begin_src emacs-lisp
(setq +ligatures-extras-in-modes '(elisp-mode org-mode))
;; (setq +ligatures-in-modes '(not special-mode comint-mode eshell-mode term-mode vterm-mode Info-mode python-mode))
#+end_src

*** Rotate (window management)

The =rotate= package just adds the ability to rotate window layouts, but that
sounds nice to me.

#+begin_src emacs-lisp :tangle packages.el
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src

*** Which-key

I don't know why this is not enabled by default, but I like being able to navigate multiple pages.
Especially if I have looked it up with =SPC h b t=.
#+begin_src emacs-lisp
(setq which-key-use-C-h-commands 't)
#+end_src

*** vterm

I like to use tmux inside vterm and use vim bindings for navigating panes and windows.
This simply disables the global =C-h= for help.
#+begin_src emacs-lisp
(map! :after vterm
      :map vterm-mode-map
      "C-a" #'vterm-send-C-a
      "C-h" #'vterm-send-C-h)
#+end_src

** Tools

*** Very Large files

The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.

#+begin_src emacs-lisp :tangle packages.el
(package! vlf :recipe (:host github :repo "emacs-straight/vlf" :files ("*.el"))
  :pin "cacdb359f8c37c6e7e4c7937462b632d22462130")
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write
  vlf-search vlf-occur vlf-follow vlf-ediff vlf
  :commands vlf vlf-mode
  :init
  <<vlf-largefile-prompt>>
  :config
  (advice-remove 'abort-if-file-too-large #'ad-Advice-abort-if-file-too-large)
  <<vlf-linenum-offset>>
  <<vlf-search-chunking>>)
#+end_src

Now, there are one or two tweaks worth applying to VLF. For starters, it goes to
the liberty of advising ~abort-if-file-too-large~, and in doing so removes the
option of opening files literally. I think that's a bit much, so we can remove
the advice and instead override ~files--ask-user-about-large-file~ (the more
                                                                     appropriate function, I think) as a simpler approach, just sacrificing the
original behaviour with src_elisp{(setq vlf-application 'always)} (which I can't
                                                                         imagine using anyway).

#+name: vlf-largefile-prompt
#+begin_src emacs-lisp :noweb-ref none
(defadvice! +files--ask-about-large-file-vlf (size op-type filename offer-raw)
  "Like `files--ask-user-about-large-file', but with support for `vlf'."
  :override #'files--ask-user-about-large-file
  (if (eq vlf-application 'dont-ask)
      (progn (vlf filename) (error ""))
    (let ((prompt (format "File %s is large (%s), really %s?"
                          (file-name-nondirectory filename)
                          (funcall byte-count-to-string-function size) op-type)))
      (if (not offer-raw)
          (if (y-or-n-p prompt) nil 'abort)
        (let ((choice
               (car
                (read-multiple-choice
                 prompt '((?y "yes")
                          (?n "no")
                          (?l "literally")
                          (?v "vlf"))
                 (files--ask-user-about-large-file-help-text
                  op-type (funcall byte-count-to-string-function size))))))
          (cond ((eq choice ?y) nil)
                ((eq choice ?l) 'raw)
                ((eq choice ?v)
                 (vlf filename)
                 (error ""))
                (t 'abort)))))))
#+end_src

As you go from one chunk fetched by VLF to the next, the displayed line number
of the first line /in each chunk/ is unchanged. I think it's reasonable to hope
for an /overall/ line number, and by tracking chunk's cumulative line numbers we
can implement this behaviour fairly easily.

#+name: vlf-linenum-offset
#+begin_src emacs-lisp :noweb-ref none
(defvar-local +vlf-cumulative-linenum '((0 . 0))
  "An alist keeping track of the cumulative line number.")

(defun +vlf-update-linum ()
  "Update the line number offset."
  (let ((linenum-offset (alist-get vlf-start-pos +vlf-cumulative-linenum)))
    (setq display-line-numbers-offset (or linenum-offset 0))
    (when (and linenum-offset (not (assq vlf-end-pos +vlf-cumulative-linenum)))
      (push (cons vlf-end-pos (+ linenum-offset
                                 (count-lines (point-min) (point-max))))
            +vlf-cumulative-linenum))))

(add-hook 'vlf-after-chunk-update-hook #'+vlf-update-linum)

;; Since this only works with absolute line numbers, let's make sure we use them.
(add-hook! 'vlf-mode-hook (setq-local display-line-numbers t))
#+end_src

The other thing that doesn't work too well with VLF is searching with anything
other than =M-x occur=. This is because trying to go to the next match at the end
of a chunk usually wraps the point to the beginning of the chunk, instead of
moving to the next chunk.

#+name: vlf-search-chunking
#+begin_src emacs-lisp :noweb-ref none
(defun +vlf-next-chunk-or-start ()
  (if (= vlf-file-size vlf-end-pos)
      (vlf-jump-to-chunk 1)
    (vlf-next-batch 1))
  (goto-char (point-min)))

(defun +vlf-last-chunk-or-end ()
  (if (= 0 vlf-start-pos)
      (vlf-end-of-file)
    (vlf-prev-batch 1))
  (goto-char (point-max)))

(defun +vlf-isearch-wrap ()
  (if isearch-forward
      (+vlf-next-chunk-or-start)
    (+vlf-last-chunk-or-end)))

(add-hook! 'vlf-mode-hook (setq-local isearch-wrap-function #'+vlf-isearch-wrap))
#+end_src


Unfortunately, since evil-search doesn't have an analogue to
~isearch-wrap-function~, we can't easily add support to it.
*** Eros

#+begin_quote
=:tools eval=
#+end_quote

Provides amazing inline evaluation of ~elisp~ using =gr= and =gR=.
Another gem from Tec's config is to make this look better
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ") ; default =>
#+end_src

*** Evil

#+begin_quote
=:editor evil=
#+end_quote

Doom's configuration of evil is reasonable and pragmatic.
However everyone has some personal preferences.
#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

*** Magit

automated commit templates seem nice to me
#+begin_src emacs-lisp
(defvar +magit-project-commit-templates-alist nil
  "Alist of toplevel dirs and template strings/functions.")
(after! magit
  (defun +magit-fill-in-commit-template ()
    "Insert template from `+magit-fill-in-commit-template' if applicable."
    (when-let ((template (and (save-excursion (goto-char (point-min)) (string-match-p "\\`\\s-*$" (thing-at-point 'line)))
                              (cdr (assoc (file-name-base (directory-file-name (magit-toplevel)))
                                          +magit-project-commit-templates-alist)))))
      (goto-char (point-min))
      (insert (if (stringp template) template (funcall template)))
      (goto-char (point-min))
      (end-of-line)))
  (add-hook 'git-commit-setup-hook #'+magit-fill-in-commit-template 90)
  )

(after! magit
  (add-to-list '+magit-project-commit-templates-alist (cons "first" (lambda () (insert (magit-get-current-branch) ": "))))
  )
#+end_src



Keymaps are a pain at the best of times and I couldn't get the normal maps to work
#+begin_src emacs-lisp
(after! evil-collection-magit
  (evil-collection-define-key 'normal
    'evil-collection-magit-toggle-text-minor-mode-map
    "\C-t" '+workspace/new)
  (evil-collection-define-key evil-collection-magit-state 'magit-mode-map
    "\C-t" '+workspace/new)
  )
#+end_src

*** Company

I both love and hate company. It make emacs better than any vim plugin system, but is also
the thing that is most likely going to slow down my typing experience.

#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.5
        company-minimum-prefix-length 3
        company-show-numbers t))
;; (add-hook
;;  'evil-normal-state-entry-hook #'company-abort))
#+end_src

Also a good idea to improve memory:
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

**** LSP optimisation

the following can help to see if its the language server or company that is slow.
Its almost always garbage collection though.
#+begin_src emacs-lisp
(setq company-idle-delay 0.01)
#+end_src

**** Plain text defaults

Having ~Ispell~ Enabled is really useful.

#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src

**** ESS

Nothing to put here currently. Look into ~company-dabbrev-code~

*** Projectile
because it faster
#+begin_src emacs-lisp
(setq projectile-indexing-method 'native)
;; (after! projectile
;;   (dolist (project myprojects)
;;     (projectile-add-known-project project)))


;; (setq projectile-project-search-path '("~/Things/"))


#+end_src
*** Smerge
The default keybindings are not the best really, and could use some improvement.
Especially in keeping all changes.
#+begin_src emacs-lisp
(defun smerge-repeatedly ()
  "Perform smerge actions again and again"
  (interactive)
  (smerge-mode 1)
  (smerge-transient))
(after! transient
  (transient-define-prefix smerge-transient ()
    [["Move"
      ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (evil-scroll-line-to-center (line-number-at-pos)) (smerge-repeatedly)))
      ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev))(evil-scroll-line-to-center (line-number-at-pos)) (smerge-repeatedly)))]
     ["Keep"
      ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
      ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
      ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
      ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
      ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
     ["Diff"
      ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
      ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
      (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
      ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
      ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
     ["Other"
      ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
      ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
      ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
      ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

Oh and I also want to bind this to a reasonable key.
#+begin_src emacs-lisp
(after! magit
  (map! :leader
        (:prefix-map ("g" . "git")
                     "m" 'smerge-repeatedly)))
#+end_src

*** flyckeck

because the default bindings are kinda dumb so everything is now =SPC c x=
#+begin_src emacs-lisp
(after! flycheck
  (map! :leader
        (:prefix-map ("c" . "code")
                     "x" flycheck-command-map)))
#+end_src

*** Ispell

SCOWL provides a nice place to get dictionaries from I would like one:

- size
80 (huge)
- spellings
British(-ise) and Australian
- spelling variants level
0
- diacritics
keep
- extra lists
hacker, roman


*** Aspell

#+begin_src shell :tangle (if (file-expand-wildcards "/usr/lib64/aspell*/en-custom.multi") "no" "setup.sh")
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && sudo make install
#+end_src


**** Configuration

Actually set the correct spelling dictionary
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src

Also having a personal dictionary that is separate from the original is useful

#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src


*** YASnippet

nested snippets are good so:
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

*** Dirvish
A very nice extension to dired that seems significantly less buggy than =ranger.el=. However there are a few things we need to to keep things in check
#+begin_src emacs-lisp
;; (setq dirvish-mode-line-format ; it's ok to place string inside
;;    '(:left (sort file-time " " file-size symlink) :right (omit yank index)))
;; (set-popup-rule! "^ \\*Dirvish.*" :ignore t)

;;   (map! :map dirvish-mode-map
;;         :n "b" #'dirvish-goto-bookmark
;;         :n "z" #'dirvish-show-history
;;         :n "f" #'dirvish-file-info-menu
;;         :n "F" #'dirvish-toggle-fullscreen
;;         :n "l" #'dired-find-file
;;         :n "h" #'dired-up-directory
;;         :n "?" #'dirvish-dispatch
;;         :n "q" #'quit-window
;;         :localleader
;;         "h" #'dired-omit-mode)


;; (after! dirvish
;;   (push '(collapse subtree-state) dirvish-attributes)
;;   (setq dired-listing-switches
;;         "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group"))

#+end_src

** Visuals

*** Info Colors

Drew Adams =info+= package is really nice but having nice colours is even better.
#+begin_src emacs-lisp :tangle packages.el
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src

simply hook into =info=

#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

*** Theme magic

Themes are sometimes hard to match in terminals especially given settings. This is a way of helping this.

#+begin_src emacs-lisp :tangle packages.el
(package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

# This operates using =pywal=, which is present in some repositories, but most
# reliably installed with =pip=.
# #+begin_src shell :eval no :tangle (if (executable-find "wal") "no" "setup.sh")
# sudo python3 -m pip install pywal
# #+end_src
Theme magic selects 8 reasonable colours to use from font faces and other data.
Unfortunately those 8 colours are used for both normal and light variants.
Fortunately =doom-themes= makes things more easy as we can use the colour utils
to generate sensible variations.

#+begin_src emacs-lisp
(use-package! theme-magic
  :commands theme-magic-from-emacs
  :config
  (defadvice! theme-magic--auto-extract-16-doom-colors ()
    :override #'theme-magic--auto-extract-16-colors
    (list
     (face-attribute 'default :background)
     (doom-color 'error)
     (doom-color 'success)
     (doom-color 'type)
     (doom-color 'keywords)
     (doom-color 'constants)
     (doom-color 'functions)
     (face-attribute 'default :foreground)
     (face-attribute 'shadow :foreground)
     (doom-blend 'base8 'error 0.1)
     (doom-blend 'base8 'success 0.1)
     (doom-blend 'base8 'type 0.1)
     (doom-blend 'base8 'keywords 0.1)
     (doom-blend 'base8 'constants 0.1)
     (doom-blend 'base8 'functions 0.1)
     (face-attribute 'default :foreground))))
#+end_src
*** Emojify

Sometimes the emoji is used over the actual character when we really want the actual character. Espeically in org mode and vterm.
#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀"
    ;; I just want to see this as text
    "©" "™")
  "Characters that should never be affected by `emojify-mode'.")


(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src


*** Magit Delta
magit's diff highlighting is already so much better than most git programs. However
=delta= is another step up. Here be some rudimentary configuration
TODO: add system installation for delta

#+begin_src emacs-lisp :tangle packages.el
(package! magit-delta)
#+end_src
its currently not enabled as a module flag in doom so we need to do it ourself
#+begin_src emacs-lisp
(after! magit
  ;; (magit-delta-mode +1)
  (setq
   magit-delta-default-dark-theme "Nord"
   magit-delta-default-light-theme "OneHalfLight"
   ))

                                        ; Fix dumb thing of magit not finding delta
;; (after! magit-delta
;;   (setq magit-delta-delta-executable "~/.cargo/bin/delta"))
#+end_src

*** Centaur Tabs

There is currently an issue when running in daemon mode [[https://github.com/doomemacs/doomemacs/issues/6647][here]]. The following seems to fix it.
#+begin_src emacs-lisp
(after! centaur-tabs
  (setq centaur-tabs-set-bar 'right))
#+end_src

** File Types

*** Systemd
#+begin_src emacs-lisp :tangle packages.el
(package! systemd)
#+end_src

#+begin_src emacs-lisp
(use-package! systemd
  :defer t)
#+end_src

* Applications

** Mail
*** Fetching
install giomap notify
#+begin_src shell :eval no :tangle (if (and (executable-find "mu") (not (executable-find "goimapnotify"))) "setup.sh" "no")
go get -u gitlab.com/shackra/goimapnotify
ln -s ~/.local/share/go/bin/goimapnotify ~/.local/bin/
#+end_src

**** Rebuild mail index whilst using mu4e
#+begin_src emacs-lisp :noweb-ref mu4e-conf
(defvar mu4e-reindex-request-file "/tmp/mu_reindex_now"
  "Location of the reindex request, signaled by existance")
(defvar mu4e-reindex-request-min-seperation 5.0
  "Don't refresh again until this many second have elapsed.
Prevents a series of redisplays from being called (when set to an appropriate value)")

(defvar mu4e-reindex-request--file-watcher nil)
(defvar mu4e-reindex-request--file-just-deleted nil)
(defvar mu4e-reindex-request--last-time 0)

(defun mu4e-reindex-request--add-watcher ()
  (setq mu4e-reindex-request--file-just-deleted nil)
  (setq mu4e-reindex-request--file-watcher
        (file-notify-add-watch mu4e-reindex-request-file
                               '(change)
                               #'mu4e-file-reindex-request)))

(defadvice! mu4e-stop-watching-for-reindex-request ()
  :after #'mu4e--server-kill
  (if mu4e-reindex-request--file-watcher
      (file-notify-rm-watch mu4e-reindex-request--file-watcher)))

(defadvice! mu4e-watch-for-reindex-request ()
  :after #'mu4e--server-start
  (mu4e-stop-watching-for-reindex-request)
  (when (file-exists-p mu4e-reindex-request-file)
    (delete-file mu4e-reindex-request-file))
  (mu4e-reindex-request--add-watcher))

(defun mu4e-file-reindex-request (event)
  "Act based on the existance of `mu4e-reindex-request-file'"
  (if mu4e-reindex-request--file-just-deleted
      (mu4e-reindex-request--add-watcher)
    (when (equal (nth 1 event) 'created)
      (delete-file mu4e-reindex-request-file)
      (setq mu4e-reindex-request--file-just-deleted t)
      (mu4e-reindex-maybe t))))

(defun mu4e-reindex-maybe (&optional new-request)
  "Run `mu4e--server-index' if it's been more than
`mu4e-reindex-request-min-seperation'seconds since the last request,"
  (let ((time-since-last-request (- (float-time)
                                    mu4e-reindex-request--last-time)))
    (when new-request
      (setq mu4e-reindex-request--last-time (float-time)))
    (if (> time-since-last-request mu4e-reindex-request-min-seperation)
        (mu4e--server-index nil t)
      (when new-request
        (run-at-time (* 1.1 mu4e-reindex-request-min-seperation) nil
                     #'mu4e-reindex-maybe)))))
#+end_src

**** Config Conversions
***** mbsync to imapnotify

When run without flags this will perform the following actions
+ Read, and parse [[file:~/.mbsyncrc][~/.mbsyncrc]], specifically recognising the following properties
- ~IMAPAccount~
- ~Host~
- ~Port~
- ~User~
- ~Password~
- ~PassCmd~
- ~Patterns~
+ Call ~mbsync --list ACCOUNT~, and filter results according to ~Patterns~
+ Construct a imapnotify config for each account, with the following hooks
- onNewMail :: src_shell{mbsync --pull ACCOUNT:MAILBOX}
- onNewMailPost :: src_shell{if mu index --lazy-check; then test -f /tmp/mu_reindex_now && rm /tmp/mu_reindex_now; else touch /tmp/mu_reindex_now; fi}
+ Compare accounts list to previous accounts, enable/disable the relevant
systemd services, called with the ~--now~ flag (start/stop services as well)

This script also supports the following flags
+ ~--status~ to get the status of the relevant systemd services supports =active=,
=failing=, and =disabled=
+ ~--enable~ to enable all relevant systemd services
+ ~--disable~ to disable all relevant systemd services
#+begin_src python :tangle misc/mbsync-imapnotify.py :shebang "#!/usr/bin/env python3"
#!/usr/bin/env python3
from pathlib import Path
import json
import re
import shutil
import subprocess
import sys
import fnmatch

mbsyncFile = Path("~/.mbsyncrc").expanduser()

imapnotifyConfigFolder = Path("~/.config/imapnotify/").expanduser()
imapnotifyConfigFolder.mkdir(exist_ok=True)
imapnotifyConfigFilename = "notify.conf"

imapnotifyDefault = {
    "host": "",
    "port": 993,
    "tls": True,
    "tlsOptions": {"rejectUnauthorized": True},
    "onNewMail": "",
    "onNewMailPost": "if mu index --lazy-check; then test -f /tmp/mu_reindex_now && rm /tmp/mu_reindex_now; else touch /tmp/mu_reindex_now; fi",
}


def stripQuotes(string):
    if string[0] == '"' and string[-1] == '"':
        return string[1:-1].replace('\\"', '"')


mbsyncInotifyMapping = {
    "Host": (str, "host"),
    "Port": (int, "port"),
    "User": (str, "username"),
    "Password": (str, "password"),
    "PassCmd": (stripQuotes, "passwordCmd"),
    "Patterns": (str, "_patterns"),
}

oldAccounts = [d.name for d in imapnotifyConfigFolder.iterdir() if d.is_dir()]

currentAccount = ""
currentAccountData = {}

successfulAdditions = []


def processLine(line):
    newAcc = re.match(r"^IMAPAccount ([^#]+)", line)

    linecontent = re.sub(r"(^|[^\\])#.*", "", line).split(" ", 1)
    if len(linecontent) != 2:
        return

    parameter, value = linecontent

    if parameter == "IMAPAccount":
        if currentAccountNumber > 0:
            finaliseAccount()
        newAccount(value)
    elif parameter in mbsyncInotifyMapping.keys():
        parser, key = mbsyncInotifyMapping[parameter]
        currentAccountData[key] = parser(value)
    elif parameter == "Channel":
        currentAccountData["onNewMail"] = f"mbsync --pull --new {value}:'%s'"


def newAccount(name):
    global currentAccountNumber
    global currentAccount
    global currentAccountData
    currentAccountNumber += 1
    currentAccount = name
    currentAccountData = {}
    print(f"\n\033[1;32m{currentAccountNumber}\033[0;32m - {name}\033[0;37m")


def accountToFoldername(name):
    return re.sub(r"[^A-Za-z0-9]", "", name)


def finaliseAccount():
    if currentAccountNumber == 0:
        return

    global currentAccountData
    try:
        currentAccountData["boxes"] = getMailBoxes(currentAccount)
    except subprocess.CalledProcessError as e:
        print(
            f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
            + f"`{' '.join(e.cmd)}' returned code {e.returncode}\033[0;37m"
        )
        return
    except subprocess.TimeoutExpired as e:
        print(
            f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
            + f"`{' '.join(e.cmd)}' timed out after {e.timeout:.2f} seconds\033[0;37m"
        )
        return

    if "_patterns" in currentAccountData:
        currentAccountData["boxes"] = applyPatternFilter(
            currentAccountData["_patterns"], currentAccountData["boxes"]
        )

    # strip not-to-be-exported data
    currentAccountData = {
        k: currentAccountData[k] for k in currentAccountData if k[0] != "_"
    }

    parametersSet = currentAccountData.keys()
    currentAccountData = {**imapnotifyDefault, **currentAccountData}
    for key, val in currentAccountData.items():
        valColor = "\033[0;33m" if key in parametersSet else "\033[0;37m"
        print(f"  \033[1;37m{key:<13} {valColor}{val}\033[0;37m")

    if (
            len(currentAccountData["boxes"]) > 15
            and "@gmail.com" in currentAccountData["username"]
    ):
        print(
            "  \033[1;31mWarning:\033[0;31m Gmail raises an error when more than"
            + "\033[1;31m15\033[0;31m simultanious connections are attempted."
            + "\n           You are attempting to monitor "
            + f"\033[1;31m{len(currentAccountData['boxes'])}\033[0;31m mailboxes.\033[0;37m"
        )

    configFile = (
        imapnotifyConfigFolder
        / accountToFoldername(currentAccount)
        / imapnotifyConfigFilename
    )
    configFile.parent.mkdir(exist_ok=True)

    json.dump(currentAccountData, open(configFile, "w"), indent=2)
    print(f" \033[0;35mConfig generated and saved to {configFile}\033[0;37m")

    global successfulAdditions
    successfulAdditions.append(accountToFoldername(currentAccount))


def getMailBoxes(account):
    boxes = subprocess.run(
        ["mbsync", "--list", account], check=True, stdout=subprocess.PIPE, timeout=10.0
    )
    return boxes.stdout.decode("utf-8").strip().split("\n")


def applyPatternFilter(pattern, mailboxes):
    patternRegexs = getPatternRegexes(pattern)
    return [m for m in mailboxes if testPatternRegexs(patternRegexs, m)]


def getPatternRegexes(pattern):
    def addGlob(b):
        blobs.append(b.replace('\\"', '"'))
        return ""

    blobs = []
    pattern = re.sub(r' ?"([^"]+)"', lambda m: addGlob(m.groups()[0]), pattern)
    blobs.extend(pattern.split(" "))
    blobs = [
        (-1, fnmatch.translate(b[1::])) if b[0] == "!" else (1, fnmatch.translate(b))
        for b in blobs
    ]
    return blobs


def testPatternRegexs(regexCond, case):
    for factor, regex in regexCond:
        if factor * bool(re.match(regex, case)) < 0:
            return False
    return True


def processSystemdServices():
    keptAccounts = [acc for acc in successfulAdditions if acc in oldAccounts]
    freshAccounts = [acc for acc in successfulAdditions if acc not in oldAccounts]
    staleAccounts = [acc for acc in oldAccounts if acc not in successfulAdditions]

    if keptAccounts:
        print(f"\033[1;34m{len(keptAccounts)}\033[0;34m kept accounts:\033[0;37m")
        restartAccountSystemdServices(keptAccounts)

    if freshAccounts:
        print(f"\033[1;32m{len(freshAccounts)}\033[0;32m new accounts:\033[0;37m")
        enableAccountSystemdServices(freshAccounts)
    else:
        print(f"\033[0;32mNo new accounts.\033[0;37m")

    notActuallyEnabledAccounts = [
        acc for acc in successfulAdditions if not getAccountServiceState(acc)["enabled"]
    ]
    if notActuallyEnabledAccounts:
        print(
            f"\033[1;32m{len(notActuallyEnabledAccounts)}\033[0;32m accounts need re-enabling:\033[0;37m"
        )
        enableAccountSystemdServices(notActuallyEnabledAccounts)

    if staleAccounts:
        print(f"\033[1;33m{len(staleAccounts)}\033[0;33m removed accounts:\033[0;37m")
        disableAccountSystemdServices(staleAccounts)
    else:
        print(f"\033[0;33mNo removed accounts.\033[0;37m")


def enableAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;32m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "enable", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;32m enabled")


def disableAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;33m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "disable", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;33m disabled")


def restartAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;34m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "restart", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;34m restarted")


def setSystemdServiceState(state, service):
    try:
        enabler = subprocess.run(
            ["systemctl", "--user", state, service, "--now"],
            check=True,
            stderr=subprocess.DEVNULL,
            timeout=5.0,
        )
        return True
    except subprocess.CalledProcessError as e:
        print(
            f" \033[1;31mfailed\033[0;31m to {state}, `{' '.join(e.cmd)}'"
            + f"returned code {e.returncode}\033[0;37m"
        )
    except subprocess.TimeoutExpired as e:
        print(f" \033[1;31mtimed out after {e.timeout:.2f} seconds\033[0;37m")
        return False


def getAccountServiceState(account):
    return {
        state: bool(
            1
            - subprocess.run(
                [
                    "systemctl",
                    "--user",
                    f"is-{state}",
                    "--quiet",
                    f"goimapnotify@{accountToFoldername(account)}.service",
                ],
                stderr=subprocess.DEVNULL,
            ).returncode
        )
        for state in ("enabled", "active", "failing")
    }


def getAccountServiceStates(accounts):
    for account in accounts:
        enabled, active, failing = getAccountServiceState(account).values()
        print(f"  - \033[1;37m{account:<18}\033[0;37m ", end="", flush=True)
        if not enabled:
            print("\033[1;33mdisabled\033[0;37m")
        elif active:
            print("\033[1;32mactive\033[0;37m")
        elif failing:
            print("\033[1;31mfailing\033[0;37m")
        else:
            print("\033[1;35min an unrecognised state\033[0;37m")


if len(sys.argv) > 1:
    if sys.argv[1]   in ["-e", "--enable"]:
        enableAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-d", "--disable"]:
        disableAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-r", "--restart"]:
        restartAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-s", "--status"]:
        getAccountServiceStates(oldAccounts)
        exit()
    elif sys.argv[1] in ["-h", "--help"]:
        print("""\033[1;37mMbsync to IMAP Notify config generator.\033[0;37m

Usage: mbsync-imapnotify [options]

Options:
    -e, --enable       enable all services
    -d, --disable      disable all services
    -r, --restart      restart all services
    -s, --status       fetch the status for all services
    -h, --help         show this help
""", end='')
        exit()
    else:
        print(f"\033[0;31mFlag {sys.argv[1]} not recognised, try --help\033[0;37m")
        exit()


mbsyncData = open(mbsyncFile, "r").read()

currentAccountNumber = 0

totalAccounts = len(re.findall(r"^IMAPAccount", mbsyncData, re.M))


def main():
    print("\033[1;34m:: MbSync to Go IMAP notify config file creator ::\033[0;37m")

    shutil.rmtree(imapnotifyConfigFolder)
    imapnotifyConfigFolder.mkdir(exist_ok=False)
    print("\033[1;30mImap Notify config dir purged\033[0;37m")

    print(f"Identified \033[1;32m{totalAccounts}\033[0;32m accounts.\033[0;37m")

    for line in mbsyncData.split("\n"):
        processLine(line)

    finaliseAccount()

    print(
        f"\nConfig files generated for \033[1;36m{len(successfulAdditions)}\033[0;36m"
        + f" out of \033[1;36m{totalAccounts}\033[0;37m accounts.\n"
    )

    processSystemdServices()


if __name__ == "__main__":
    main()
#+end_src


As long as the =mbsyncrc= file exists, this is as easy as running
#+begin_src shell :tangle (if (and (executable-find "mu") (not (file-exists-p "~/.config/imapnotify"))) "setup.sh" "no")
~/.config/doom/misc/mbsync-imapnotify.py
#+end_src
***** mbsync to msmtp

#+begin_src python :tangle misc/mbsync-msmtp.py :shebang "#!/usr/bin/env python3"
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List
import json
import shutil
import os


mbsyncFile = Path("~/.mbsyncrc").expanduser()
msmtpFile = Path("~/.msmtprc").expanduser()
default_port = 587
field_map = {
    "name": "account",
    "host": "host",
    "port": "port",
    "from_address": "from",
    "user": "user",
    "password_expression": "passwordeval",
}

msmtpDefaults = {
    "defaults": "",
    "auth": "on",
    "tls": "on",
    "tls_trust_file": "/etc/ssl/certs/ca-certificates.crt",
    "logfile": "~/.msmtp.log",
}


def export_defaults(defaults):
    return "\n".join(f"{field:<20}{value}" for field, value in msmtpDefaults.items())


@dataclass(init=False)
class MsmtpAccount:
    name: str = ""
    host: str = ""
    port: int = 0
    from_address: str = ""
    user: str = ""
    password_expression: str = ""

    def export(self):
        return "\n".join(
            [f"{field_map[field]:<20}{value}" for field, value in asdict(self).items()]
        )


accounts: List[MsmtpAccount] = []


def parse_mbsync_file():
    cur = None
    with open(mbsyncFile, "r") as f:
        for line in f:
            if line.startswith("IMAPAccount"):
                cur = MsmtpAccount()
                cur.name = line.strip().split()[1]
                cur.port = default_port
            if line.startswith("Host"):
                cur.host = line.strip().split()[1].replace("imap", "smtp")
            if line.startswith("User"):
                cur.from_address = line.strip().split()[1]
                cur.user = cur.from_address.split("@")[0]
            if line.startswith("PassCmd"):
                cur.password_expression = " ".join(line.strip().split()[1:])
                accounts.append(cur)


def write_file():
    with open(msmtpFile, "w") as f:
        f.write(export_defaults(msmtpDefaults) + "\n\n")
        for acct in accounts:
            if acct != None:
                print(acct.name)
                f.write(acct.export() + "\n\n")
        f.write(f"account default : {accounts[0].name}")


def main():
    print("\033[1;34m:: MbSync to msmtp config file creator ::\033[0;37m")

    shutil.move(msmtpFile, msmtpFile.with_suffix(".old"))
    print("\033[1;30msmtp config file moved to .msmtprc.old\033[0;37m")

    parse_mbsync_file()
    write_file()
    print("\033[1;34m Complete \033[0;37m")


if __name__ == "__main__":
    main()
#+end_src
**** Systemd Services
A template service file so we can enable a unit per-account.
#+begin_src systemd :tangle ~/.config/systemd/user/goimapnotify@.service
[Unit]
Description=IMAP notifier using IDLE, golang version.
ConditionPathExists=%h/.config/imapnotify/%I/notify.conf
After=network.target

[Service]
ExecStart=/usr/bin/goimapnotify -conf %h/.config/imapnotify/%I/notify.conf
Restart=always
RestartSec=30

[Install]
WantedBy=default.target
#+end_src

Enabling the service is actually taken care of by that python script.

#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync.timer" "no")
[Unit]
Description=call mbsync on all accounts every 5 minutes
ConditionPathExists=%h/.mbsyncrc

[Timer]
OnBootSec=5m
OnUnitInactiveSec=5m

[Install]
WantedBy=default.target
#+end_src

#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync.service" "no")
[Unit]
Description=mbsync service, sync all mail
Documentation=man:mbsync(1)
ConditionPathExists=%h/.mbsyncrc

[Service]
Type=oneshot
ExecStart=/usr/bin/mbsync -c %h/.mbsyncrc --all

[Install]
WantedBy=mail.target
#+end_src

Enabling (and starting) this is as simple as
#+begin_src shell :tangle (if (or (not (executable-find "mu")) (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled mbsync.timer"))) "no" "setup.sh")
systemctl --user enable mbsync.timer --now
#+end_src


#TODO: put something in setup script to deal with this and put in right place

its a bit buggy tbh
#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync-resume.service" "no")
[Unit]
Description=sync mail after resume
Documentation=man:mbsync(1)
Requires=network-online.target
After=network-online.target suspend.target

[Service]
Type=simple
# Environment="HOME=/home/dadams"
ExecStartPre=/bin/sleep 10
User=dadams
ExecStart=/usr/bin/mbsync -c /home/dadams/.mbsyncrc --all

[Install]
WantedBy=suspend.target
#+end_src

*** Indexing

Enabling (and starting) this is as simple as
#+begin_src shell :tangle (if (or (not (executable-find "mu")) (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled mbsync.timer"))) "no" "setup.sh")
systemctl --user enable mbsync.timer --now
#+end_src
*** Sending
*** Mu4e
This is here because of some weird ass property drawer errors
#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(after! mu4e
  <<mu4e-conf>>)
#+end_src

**** Viewing Mail
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref mu4e-conf
:END:

Browser good for rendering not good for email applications.

To account for the increase width of each flag character, and make perform a
few more visual tweaks, we'll tweak the headers a bit

#+begin_src emacs-lisp
(setq mu4e-headers-fields
      '((:flags . 6)
        (:account-stripe . 2)
        (:from-or-to . 25)
        (:folder . 10)
        (:recipnum . 2)
        (:subject . 80)
        (:human-date . 8))
      +mu4e-min-header-frame-width 142
      mu4e-headers-date-format "%d/%m/%y"
      mu4e-headers-time-format "⧖ %H:%M"
      mu4e-headers-results-limit 1000
      mu4e-index-cleanup t)

(add-to-list 'mu4e-bookmarks
             '(:name "Yesterday's messages" :query "date:2d..1d" :key ?y) t)

(defvar +mu4e-header--folder-colors nil)
(appendq! mu4e-header-info-custom
          '((:folder .
             (:name "Folder" :shortname "Folder" :help "Lowest level folder" :function
                    (lambda (msg)
                      (+mu4e-colorize-str
                       (replace-regexp-in-string "\\`.*/" "" (mu4e-message-field msg :maildir))
                       '+mu4e-header--folder-colors))))))
#+end_src
We'll also use a nicer alert icon or not
#+begin_src emacs-lisp
;; (setq mu4e-alert-icon "/usr/share/icons/Papirus/64x64/apps/evolution.svg")
#+end_src
**** Contexts
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref mu4e-conf
:END:

These be important
#+begin_src emacs-lisp
(setq mu4e-context-policy 'pick-first)
(setq mu4e-compose-context-policy 'always-ask)
(setq mu4e-compose-format-flowed t)
(load! "private/email.el")
#+end_src

**** Sending Mail
:PROPERTIES:
:header-args:emacs-lisp: tangle: no :noweb-ref mu4e-conf
:END:
Let's send emails too.
#+begin_src emacs-lisp
(setq sendmail-program "/usr/bin/msmtp"
      send-mail-function #'smtpmail-send-it
      message-sendmail-f-is-evil t
      message-sendmail-extra-arguments '("--read-envelope-from"); , "--read-recipients")
      message-send-mail-function #'message-send-mail-with-sendmail)
#+end_src

We also want to define ~mu4e-compose-from-mailto~.

#+begin_src emacs-lisp
(defun mu4e-compose-from-mailto (mailto-string &optional quit-frame-after)
  (require 'mu4e)
  (unless mu4e~server-props (mu4e t) (sleep-for 0.1))
  (let* ((mailto (message-parse-mailto-url mailto-string))
         (to (cdr (assoc "To" mailto)))
         (subject (or (cdr (assoc "Subject" mailto)) ""))
         (body (cdr (assoc "Body" mailto)))
         (headers (-filter (lambda (spec) (not (-contains-p '("To" "Subject" "Body") (car spec)))) mailto)))
    (when-let ((mu4e-main (get-buffer mu4e-main-buffer-name)))
      (switch-to-buffer mu4e-main))
    (mu4e~compose-mail to subject headers)
    (when body
      (goto-char (point-min))
      (if (eq major-mode 'org-msg-edit-mode)
          (org-msg-goto-body)
        (mu4e-compose-goto-bottom))
      (insert body))
    (goto-char (point-min))
    (cond ((null to) (search-forward "To: "))
          ((string= "" subject) (search-forward "Subject: "))
          (t (if (eq major-mode 'org-msg-edit-mode)
                 (org-msg-goto-body)
               (mu4e-compose-goto-bottom))))
    (font-lock-ensure)
    (when evil-normal-state-minor-mode
      (evil-append 1))
    (when quit-frame-after
      (add-hook 'kill-buffer-hook
                `(lambda ()
                   (when (eq (selected-frame) ,(selected-frame))
                     (delete-frame)))))))
#+end_src

It would also be nice to change the name pre-filled in =From:= when drafting.
#+begin_src emacs-lisp
(defvar mu4e-from-name "David"
  "Name used in \"From:\" template.")
(defadvice! mu4e~draft-from-construct-renamed (orig-fn)
  "Wrap `mu4e~draft-from-construct-renamed' to change the name."
  :around #'mu4e~draft-from-construct
  (let ((user-full-name mu4e-from-name))
    (funcall orig-fn)))
#+end_src

We can also use this a signature,

#+begin_src emacs-lisp
(setq message-signature mu4e-from-name)
#+end_src

#+begin_src emacs-lisp
(setq mu4e-compose-signature "David")
#+end_src


**** some visual improvements
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref mu4e-conf
:END:

just makes the icons slightly better for unicode fonts
#+begin_src emacs-lisp
(cl-flet* ((make-help-button (text help-echo)
             (with-temp-buffer
               (insert-text-button text
                                   'help-echo help-echo
                                   'mouse-face nil)
               (buffer-string)))
           (make-help-button-cons (text1 text2 help-echo)
             (cons (make-help-button text1 help-echo)
                   (make-help-button text2 help-echo))))
  (setq mu4e-headers-threaded-label
        (make-help-button-cons "T" (concat " " (all-the-icons-octicon "git-branch" :v-adjust 0.05))
                               "Thread view")
        mu4e-headers-related-label
        (make-help-button-cons "R" (concat " " (all-the-icons-material "link" :v-adjust -0.1))
                               "Showing related emails")
        mu4e-headers-full-label
        (make-help-button-cons "F" (concat " " (all-the-icons-material "disc_full"))
                               "Search is full!")))
#+end_src

*** Notifications
the main version of mu4e alert is kinda broken which is a shame. Need to keep an
eye on [[https://github.com/iqbalansari/mu4e-alert/issues/40][main issue]]. Untill then at least this fork is *slightly* less broken
#+begin_src emacs-lisp :tangle "packages.el"
(package! mu4e-alert
  :recipe (:host github :repo "xzz53/mu4e-alert"))
#+end_src
** RSS/Newsfeed Reader

elfeed is great
#+begin_src emacs-lisp
(after! elfeed
  (map! :leader
        (:prefix-map ("o" . "open")
                     "l" #'elfeed)))
#+end_src


* Languages
** Org

The beginning of a great journey

#+begin_src elisp :noweb no-export :noweb-prefix no 
(after! org
  <<org-conf>>
  )
#+end_src

*** Basic configuration
#+begin_src emacs-lisp
(setq org-directory "~/Org/")
(setq +org-capture-todo-file (da/sub-work "~/Org/todo.org" "~/Org/work/todo.org"))
(setq org-agenda-files '("~/Org/experiments.org"
                         "~/Org/mylife.org"
                         "~/Org/birthday.org"
                         "~/Org/longrunning.org"
                         "~/Org/Mail.org"))

(setq org-return-follows-link t) ;; I like following links
(setq org-use-speed-commands t) ;; gotta go fast
(setq org-deadline-past-days 14)
(setq org-deadline-warning-days 30)
(setq org-agenda-start-with-log-mode t)
(setq org-log-done t)
(setq org-log-refile 'time) ;; I refile a lot so don't want to be asked for notes
(setq org-log-reschedule t)
(setq org-agenda-restore-windows-after-quit t) ;; return me to buffers i want to go to
(setq org-log-into-drawer t)
(setq org-enforce-todo-dependencies t)
(setq org-track-ordered-property-with-tag t) ;; make it more visible that things are ordered
(setq org-refile-allow-creating-parent-nodes t)
(setq org-archive-location (da/sub-work "~/Org/Archive.org::datetree/* Finished Tasks " "~/Org/work/work_archive.org::datetree/ "))
(setq org-clock-into-drawer "CLOCKING")
(setq org-refile-targets
      '(("Archive.org" :maxlevel . 1)
        ("mylife.org" :maxlevel . 1)
        ("longrunning.org" :maxlevel . 1)
        ("~/Org/work/todo.org" :maxlevel . 1)))


(defun da/org-refile-all-todos ()
  "Refile all TODO entries in the current org-mode file."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "TODO" nil t)
      (org-refile))))
;; Save Org buffers after refiling!
;; (advice-add 'org-refile :after 'org-save-all-org-buffers)
#+end_src
*** Modules
#+begin_src emacs-lisp
(after! org
  (setq org-modules
        '(;; ol-w3m
          ;; ol-bbdb
          ol-bibtex
          org-habit
          ;; ol-docview
          ;; ol-gnus
          ;; ol-info
          ;; ol-irc
          ;; ol-mhe
          ;; ol-rmail
          ;; ol-eww
          ))
  )
#+end_src

*** Config
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:

**** Custom agenda commands
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("d" "Dashboard"
         ((agenda "" ((org-deadline-warning-days 7)))
          (todo "NEXT"
                ((org-agenda-overriding-header "Next Tasks")))
          (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

        ("n" "Next Tasks"
         ((todo "NEXT"
                ((org-agenda-overriding-header "Next Tasks")))))

        ("W" "Work Tasks" tags-todo "+work-email")

        ;; Low-effort next actions
        ("e" tags-todo "+TODO=\"TODO\"+Effort<15&+Effort>0"
         ((org-agenda-overriding-header "Low Effort Tasks")
          (org-agenda-max-todos 20)
          (org-agenda-files org-agenda-files)))

        ("w" "Workflow Status"
         ((todo "WAIT"
                ((org-agenda-overriding-header "Waiting on External")
                 (org-agenda-files org-agenda-files)))
          (todo "REVIEW"
                ((org-agenda-overriding-header "In Review")
                 (org-agenda-files org-agenda-files)))
          (todo "PLAN"
                ((org-agenda-overriding-header "In Planning")
                 (org-agenda-todo-list-sublevels nil)
                 (org-agenda-files org-agenda-files)))
          (todo "BACKLOG"
                ((org-agenda-overriding-header "Project Backlog")
                 (org-agenda-todo-list-sublevels nil)
                 (org-agenda-files org-agenda-files)))
          (todo "READY"
                ((org-agenda-overriding-header "Ready for Work")
                 (org-agenda-files org-agenda-files)))
          (todo "ACTIVE"
                ((org-agenda-overriding-header "Active Projects")
                 (org-agenda-files org-agenda-files)))
          (todo "COMPLETED"
                ((org-agenda-overriding-header "Completed Projects")
                 (org-agenda-files org-agenda-files)))
          (todo "CANC"
                ((org-agenda-overriding-header "Cancelled Projects")
                 (org-agenda-files org-agenda-files)))))))

#+end_src
**** Todo Keywords

The ~@~ character indicates note with timestamp and ~!~ is just timestamp
~@/!~ note recorded when entering and timestamp when leaving
#+begin_src emacs-lisp

(setq org-todo-keywords
      '((sequence
         "TODO(t!)"       ; A task that needs doing & is ready to do
         "PROJ(p)"       ; A project, which usually contains other tasks
         "LOOP(r)"       ; A recurring task
         "STRT(s)"       ; A task that is in progress
         "WAIT(w@/!)"       ; Something external is holding up this task
         "HOLD(h)"       ; This task is paused/on hold because of me
         "IDEA(i)"       ; An unconfirmed and unapproved task or notion
         "NEXT(n!)"       ; Something to consider doing
         "|"
         "DONE(d@)"       ; Task successfully completed
         "CANCELLED(k)"
         ) ; Task was cancelled, aborted or is no longer applicable
        (sequence
         "[ ](T)"        ; A task that needs doing
         "[-](S)"        ; Task is in progress
         "[?](W)"        ; Task is being held up or paused
         "|"
         "[X](D)"))      ; Task was completed
      ;; (sequence
      ;;  "|"
      ;;  "OKAY(o)"
      ;;  "YES(y)"
      ;;  "NO(n)"))
      org-todo-keyword-faces
      '(("[-]"  . +org-todo-active)
        ("STRT" . +org-todo-active)
        ("[?]"  . +org-todo-onhold)
        ("WAIT" . +org-todo-onhold)
        ("HOLD" . +org-todo-onhold)
        ("PROJ" . +org-todo-project)
        ;; ("NO"   . +org-todo-cancel)
        ("CANCELLED" . +org-todo-cancel)))


(setq org-tag-alist
      '((:startgroup)
                                        ; Put mutually exclusive tags here
        (:endgroup)
        ("@errand" . ?E)
        ("@home" . ?H)
        ("@work" . ?W)
        ("computer" . ?c)
        ("agenda" . ?a)
        ("planning" . ?p)
        ("publish" . ?P)
        ("batch" . ?b)
        ("note" . ?n)
        ("idea" . ?i)))
#+end_src
**** Capture Templates
a straight rip of the doom config
#+begin_src emacs-lisp
(defvar my/org-contacts-template
  (concat "* %(org-contacts-template-name)\n"
          ":PROPERTIES:\n"
          ":EMAIL: %^{EMAIL}\n"
          ":NOTE: %^{NOTE}\n"
          ":END:") "Template for a contact.")

(setq org-capture-templates
      `(("t" "Personal todo" entry
         (file+headline +org-capture-todo-file "Inbox")
         "* TODO %?\n%i:LOGBOOK:\n- Added: %U\n:END:\n\n%a" :prepend t)
        ("n" "Personal notes" entry
         (file+headline +org-capture-notes-file "Inbox")
         "* %u %?\n%i\n%a" :prepend t)
        ("j" "Journal" entry
         (file+olp+datetree +org-capture-journal-file)
         "* %U %?\n%i\n%a" :prepend t)

        ("w" "Web Capture" entry
         (file+headline +org-capture-todo-file "Inbox")
         "* %?\n:LOGBOOK:\n- Added: %U\n:END:\n\n%i\n%a" :prepend t)

        ;; Will use {project-root}/{todo,notes,changelog}.org, unless a
        ;; {todo,notes,changelog}.org file is found in a parent directory.
        ;; Uses the basename from `+org-capture-todo-file',
        ;; `+org-capture-changelog-file' and `+org-capture-notes-file'.
        ("p" "Templates for projects")
        ("pt" "Project-local todo" entry  ; {project-root}/todo.org
         (file+headline +org-capture-project-todo-file "Inbox")
         "* TODO %?\n%i\n%a" :prepend t)
        ("pn" "Project-local notes" entry  ; {project-root}/notes.org
         (file+headline +org-capture-project-notes-file "Inbox")
         "* %U %?\n%i\n%a" :prepend t)
        ("pc" "Project-local changelog" entry  ; {project-root}/changelog.org
         (file+headline +org-capture-project-changelog-file "Unreleased")
         "* %U %?\n%i\n%a" :prepend t)

        ("c" "Contact" entry (file+headline "~/Org/contacts.org" "Inbox"),
         my/org-contacts-template
         :empty-lines 1)
        ;; Will use {org-directory}/{+org-capture-projects-file} and store
        ;; these under {ProjectName}/{Tasks,Notes,Changelog} headings. They
        ;; support `:parents' to specify what headings to put them under, e.g.
        ;; :parents ("Projects")
        ("o" "Centralized templates for projects")
        ("ot" "Project todo" entry
         (function +org-capture-central-project-todo-file)
         "* TODO %?\n %i\n %a"
         :heading "Tasks"
         :prepend nil)
        ("on" "Project notes" entry
         (function +org-capture-central-project-notes-file)
         "* %U %?\n %i\n %a"
         :heading "Notes"
         :prepend t)
        ("oc" "Project changelog" entry
         (function +org-capture-central-project-changelog-file)
         "* %U %?\n %i\n %a"
         :heading "Changelog"
         :prepend t)


        ;; the +2d is the SLA for how long you want an email to be

        ("m" "Email Workflow")
        ("mf" "Follow Up" entry (file+olp "~/Org/Mail.org" "Follow Up")
         "* TODO Follow up with %:fromname on %a\nSCHEDULED:%t\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))\n\n%i")
        ("mr" "Read Later" entry (file+olp "~/Org/Mail.org" "Read Later")
         "* TODO Read %:subject\nSCHEDULED:%t\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))\n\n%a\n\n%i" :immediate-finish t))
      )
#+end_src
**** Mu4e Capture Templates
[[*Mu4e][Mu4e]]
#+begin_src emacs-lisp

(defun efs/capture-mail-follow-up (msg)
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "mf"))

(defun efs/capture-mail-read-later (msg)
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "mr"))

;; Add custom actions for our capture templates
(after! mu4e
  (add-to-list 'mu4e-headers-actions
               '("follow up" . efs/capture-mail-follow-up) t)
  (add-to-list 'mu4e-view-actions
               '("follow up" . efs/capture-mail-follow-up) t)
  (add-to-list 'mu4e-headers-actions
               '("read later" . efs/capture-mail-read-later) t)
  (add-to-list 'mu4e-view-actions
               '("read later" . efs/capture-mail-read-later) t)
  )
#+end_src

**** latex interactions
#+begin_src emacs-lisp
(setq org-latex-packages-alist
      (quote (("" "color" t)
              ("" "parskip" t)
              ("" "tikz" t))))
#+end_src
*** Roam
just set where I want things to be
#+begin_src emacs-lisp
(setq org-roam-directory "~/Roam")
#+end_src

I like having a keybinding for inserting org roam notes
#+begin_src emacs-lisp
(map! :map org-mode-map
      :after org
      "C-S-n" #'org-roam-node-insert)
#+end_src

**** Templates
#+begin_src emacs-lisp


(setq org-roam-capture-templates
      `(
        ("d" "default" plain "%?"
         :if-new
         (file+head "Inbox/${title}.org" "#+title: ${title}\n")
         :immediate-finish t
         :unnarrowed t  )
        ))

;; old templates to consider for future use
;; (setq org-roam-capture-templates
;;       '(("m" "main" plain
;;          "%?"
;;          :if-new (file+head "main/${slug}.org"
;;                             "#+title: ${title}\n")
;;          :immediate-finish t
;;          :unnarrowed t)
;;         ("r" "reference" plain "%?"
;;          :if-new
;;          (file+head "reference/${title}.org" "#+title: ${title}\n")
;;          :immediate-finish t
;;          :unnarrowed t)
;;         ("a" "article" plain "%?"
;;          :if-new
;;          (file+head "articles/${title}.org" "#+title: ${title}\n#+filetags: :article:\n")
;;          :immediate-finish t
;;          :unnarrowed t)))


#+end_src
**** Advanced configuration

#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates) ;; don't show the capture buffer for different templates
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))


(defun da/org-roam-filter-by-tag (tag-name)
  (lambda (node)
    (member tag-name (org-roam-node-tags node))))

(defun da/org-roam-list-notes-by-tag (tag-name)
  (mapcar #'org-roam-node-file
          (seq-filter
           (da/org-roam-filter-by-tag tag-name)
           (org-roam-node-list))))

;; TODO change "article to a tag that happens when node is not populated so it always goes into agenda"
(defun da/org-roam-refresh-agenda-list ()
  (interactive)
  (setq org-agenda-files (da/org-roam-list-notes-by-tag "article")))

(defun my/org-roam-capture-task ()
  (interactive)
  ;; Add the project file to the agenda after capture is finished
  (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

  ;; Capture the new task, creating the project file if necessary
  (org-roam-capture- :node (org-roam-node-read
                            nil
                            (my/org-roam-filter-by-tag "Project"))
                     :templates '(("p" "project" plain "* TODO %?"
                                   :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                          "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                          ("Tasks"))))))

;; Build the agenda list the first time for the session
;; (my/org-roam-refresh-agenda-list)
(defun my/org-roam-copy-todo-to-today ()
  (interactive)
  (let ((org-refile-keep t) ;; Set this to nil to delete the original!
        (org-roam-dailies-capture-templates
         '(("t" "tasks" entry "%?"
            :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("Tasks")))))
        (org-after-refile-insert-hook #'save-buffer)
        today-file
        pos)
    (save-window-excursion
      (org-roam-dailies--capture (current-time) t)
      (setq today-file (buffer-file-name))
      (setq pos (point)))

    ;; Only refile if the target file is different than the current file
    (unless (equal (file-truename today-file)
                   (file-truename (buffer-file-name)))
      (org-refile nil nil (list "Tasks" today-file nil pos)))))

(after! org
  (add-to-list 'org-after-todo-state-change-hook
               (lambda ()
                 (when (equal org-state "DONE")
                   (my/org-roam-copy-todo-to-today))))
  )
#+end_src
**** org-roam-ui

a fantastic package for visualising my content and knowledge
#+begin_src emacs-lisp
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org ;; or :after org
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src


*** Jupyter notebook
#+begin_src emacs-lisp

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (julia . t)
   (python . t)
   (jupyter . t)))

(setq org-babel-default-header-args:jupyter-python '((:async . "yes")
                                                     (:session . "py")
                                                     (:kernel . "python3")))
#+end_src

*** Contacts
#+begin_src emacs-lisp
(after! org-contacts
  (setq org-contacts-files '("~/Org/contacts.org")))
#+end_src
*** Calendar Syncing

Calendar syncing appears to be a little bit of a mess
There are conflicting outdated views on various forums
- [[https://www.reddit.com/r/emacs/comments/2mg1q0/syncing_between_orgmode_and_google_calendar/][ical?]]
- [[https://www.reddit.com/r/emacs/comments/5qd8co/best_method_for_orgmode_google_calendar/][reddit on google calendar integration]]
- [[https://www.reddit.com/r/orgmode/comments/jxl4f3/sync_calendars_to_orgmode_agenda/][syncing calendars to org-mode agenda]]
- [[https://superuser.com/questions/176835/syncing-google-calendar-gcal-and-emacs-org-mode-is-it-possible][super user comments]]
- [[https://www.reddit.com/r/orgmode/comments/x046ec/orggcal_or_something_else_in_2022/][2022 reddit post]]
- [[https://200ok.ch/posts/2022-02-13_integrating_org_mode_agenda_into_other_calendar_apps.html][custom post]]
- [[https://joonro.github.io/blog/posts/org-mode-google-calendar-sync-in-windows/][syncing calendars on windows]]
- [[https://cestlaz.github.io/posts/using-emacs-26-gcal/#.WIqBud9vGAk][custom org-gcal]]

An [[https://orgmode.org/worg/org-tutorials/org-google-sync.html][official tutorial]] which has links to proper solutions but appears to be outdated

Otherwise there are two ways to go:
**** [[https://github.com/dengste/org-caldav][org-caldav]]
which works with other calendar providers not just google, but to quote the author
#+begin_quote
CalDAV is a mess.
#+end_quote
**** [[https://github.com/kidd/org-gcal.el][org-gcal]]
appears to be the most popular and well used solution. This is despite its confusing forks and [[https://github.com/kidd/org-gcal.el/issues/213][outdated readme]]

#+begin_src emacs-lisp :tangle packages.el
(package! org-gcal)
#+end_src

The basic config is as follows:
#+begin_src emacs-lisp
(after! org-gcal
  (setq org-gcal-fetch-file-alist '(("davidbadams110@gmail.com" .  "~/Org/schedule.org"))
      fap//org-gcal--warning-period "-1d")
(setq plstore-cache-passphrase-for-symmetric-encryption t)
(load-library "~/.doom.d/org-gcal-secrets.el.gpg"))
#+end_src
there may be some work to do here about better lazy loading but this will do for now

The load library is curtousy of [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][mastering emacs]]

some extra config inspiration from [[https://github.com/fapdash/dotfiles/blob/e370d5c7633c78e072259acec0057922c660a191/emacs/.emacs#L1168][fapdash]]
#+begin_src emacs-lisp
(defun fap//org-gcal-add-warning-period (_calendar-id event _update-mode)
  "Add a warning period to the plain timestamp in the gcal drawer. Warning periods for plain timestamps are supported by Orgzly."
  (when (not (org-gcal--event-cancelled-p event))
    (org-back-to-heading)
    (org-narrow-to-element)
    (when (re-search-forward
           (format "^[ \t]*:%s:[ \t]*$" org-gcal-drawer-name)
           (point-max)
           'noerror)
      (forward-line 1)
      (when
          (re-search-forward org-element--timestamp-regexp (point-at-eol) 'noerror)
        (replace-match (concat "<" (match-string 1) " " fap//org-gcal--warning-period ">"))))))
(add-hook 'org-gcal-after-update-entry-functions #'fap//org-gcal-add-warning-period)
#+end_src

if syncing does not appear to be working try [[https://github.com/kidd/org-gcal.el/issues/103][some of these steps]]

there is currently a bug such that if the repeating event is longer than up days it will archive all of the repeating events see [[https://github.com/kidd/org-gcal.el/issues/121][this issue]]. The choices are to see =org-gcal-recurring-events-mode= to =top-level= or =org-gcal-auto-archive= to ='nil=

** Python
TODO: fix this crap
#+begin_src emacs-lisp
;; (after! conda
;;   (setq conda-anaconda-home "~/micromamba")
;; )
#+end_src
** Graphviz
Graphviz is a nice method of visualising simple graphs, based on plaintext
=.dot= / =.gv= files.
#+begin_src emacs-lisp :tangle packages.el
(package! graphviz-dot-mode :pin "6e96a89762760935a7dff6b18393396f6498f976")
#+end_src

#+begin_src emacs-lisp
(use-package! graphviz-dot-mode
  :commands graphviz-dot-mode
  :mode ("\\.dot\\'" . graphviz-dot-mode)
  :init
  (after! org
    (setcdr (assoc "dot" org-src-lang-modes)
            'graphviz-dot)))

(use-package! company-graphviz-dot
  :after graphviz-dot-mode)
#+end_src

** Regex

#+begin_src emacs-lisp
(setq reb-re-syntax 'string)
#+end_src

*   The rest

#+begin_src emacs-lisp
(defun execute-macro-slow (&optional slot delay rand-delay)
  (interactive)
  (let ((macro (append (evil-get-register (or slot (read-char "@-")) t) nil))
        (delay (or delay 0.01))
        (rand-delay (or rand-delay 0.01)))
    (if (listp macro)
        (while macro
          (if (eq (car macro) (aref (kbd "M-x") 0)) ; Needs M-x + cmd + RET
              (let (mx-cmd)
                (while (not (eq (car mx-cmd) 'return))
                  (push (pop macro) mx-cmd))
                (execute-kbd-macro (vconcat (nreverse mx-cmd))))
            (execute-kbd-macro (vector (pop macro))))
          (sleep-for (* rand-delay (cl-random 0.5)))
          (sit-for delay))
      (message "Slot is empty/invalid."))))


(defun da-delete-regex-whole-buffer (regex)
  (save-excursion
    (goto-char (point-min))
    (delete-matching-lines regex)
    )
  )

(defun da-apply-regex-whole-buffer (regex replace)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward regex nil t)
      (replace-match replace)
      )
    )
  )

(defun da-clean-stacktrace ()
  ;; should have datetime removed
  (da-delete-regex-whole-buffer "^[[:space:]]+at[[:space:]].*model\\.property\\..*")
  (da-delete-regex-whole-buffer "^.*Lambda\$[[:digit:]]+.*")
  (da-delete-regex-whole-buffer "^.*DebugIfSlowEvent\.debugIfSlowOnEDT.*")
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "^[[:space:]]+at[[:space:]].*$" nil t)
      (replace-regexp ",[[:space:]]" ",")
      (replace-match replace)
      )
    )
  )

(defun da-clean-dead ()
  (interactive)
  (goto-char (point-min))
  (if (re-search-forward "\\([[:digit:]]+\\) \\(\\([[:digit:]]+:\\)+\\) WARNING: com.dugeo.util.swing.DeadlockDetector$DeadlockException" nil t)
      (let ((capture1 (match-string 1))
            (capture2 (match-string 2)))
        (message "Captured groups: %s, %s" capture1 capture2)
        (da-apply-regex-whole-buffer  (concat capture1 " " capture2 "java.lang.") (concat capture1 "-" capture2 "java.lang."))
        (da-apply-regex-whole-buffer  (concat capture1 " " capture2) "")
        (da-clean-stacktrace)
        ))
  )

;; set auto mode for keymaps

(add-to-list 'auto-mode-alist '("\\.keymap\\'" . c-mode))

;; fun with link inserts
;; todo make this get the window title and fix other stuff
(defun da/insert-firefox-url ()
  "Insert the URL of the currently open tab in Firefox."
  (interactive)
  (setq script-path (expand-file-name "get_firefox_url.sh" doom-private-dir))
  (setq url (shell-command-to-string script-path))
  (setq url (string-trim url)) ; Remove leading/trailing whitespace
  (insert (format "[[%s][%s]]" url url)))

(defun da/refile-all-todo-headings ()
  "Refile all TODO headings in the current Org mode buffer."
  (interactive)
  (org-map-entries
   (lambda ()
     (when (string= "TODO" (org-get-todo-state))
       (org-refile)))
   "/TODO" 'tree))

;; (after! tramp
;; (setq tramp-shell-prompt-pattern "^[^$>\n]*[#$%>] *\\(\[[0-9;]*[a-zA-Z] *\\)*"))

#+end_src
* Org Jira things

#+begin_src emacs-lisp
(setq jiralib-url "https://jira.dug.com")
#+end_src

* Other packages

#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.
(package! impatient-mode)
(package! ox-gfm)
(package! ztree)
(package! pair-tree)
(package! org-jira)
(package! restclient)
(package! org-web-tools)
(package! catppuccin-theme)
(unpin! mu4e)
(unpin! evil-collection)
(package! libmpdee
  :recipe (:host github :repo "andyetitmoves/libmpdee"))
(package! mingus
  :recipe (:host github :repo "pft/mingus"))
(unpin! org-roam)
(package! org-roam-ui)
(package! grab-x-link
  :recipe (:host github :repo "xuchunyang/grab-x-link"))
(package! demap)
(package! svg-lib)
(package! svg-tag-mode)

;; (package! ibrowse
;;  :recipe (:host github :repo "nicolas-graves/ibrowse.el"))
;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;; firefox --remote-debugging-port=9222
                                        ;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
                                        ;(package! another-package
                                        ;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
                                        ;(package! this-package
                                        ;  :recipe (:host github :repo "username/repo"
                                        ;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
                                        ;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
                                        ;(package! builtin-package :recipe (:nonrecursive t))
                                        ;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
                                        ;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
                                        ;(package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
                                        ;(unpin! pinned-package)
;; ...or multiple packages
                                        ;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
                                        ;(unpin! t)
#+end_src
