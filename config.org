#+title: Doom Emacs Configuration
#+author: Dadams

* Table of Contents :TOC:
- [[#preamble][Preamble]]
- [[#the-simple-stuff][The simple stuff]]
  - [[#personal-info][Personal info]]
  - [[#default-settings][Default settings]]
  -  [[#doom-config][Doom Config]]
  - [[#other-stuff][Other stuff]]
- [[#packages][Packages]]
  - [[#loading-instructions][Loading instructions]]
  - [[#convenience][Convenience]]
  - [[#tools][Tools]]
  - [[#visuals][Visuals]]
  - [[#file-types][File Types]]
- [[#applications][Applications]]
  - [[#mail][Mail]]
- [[#languages][Languages]]
  - [[#python][Python]]
-   [[#the-rest][The rest]]

* Preamble

I don't really know what I am doing, but it seems fun. If you want an actual representation of something good check out [[https://tecosaur.github.io/emacs-config/config.html][Tecosaurs Config]].

A note to the unweary adventurer. At no point in this config should you put the line:
#+begin_src org :tangle no
#+ +begin_src emacs-lisp tangle: "yes"
#+end_src
Org assumes the =tangle: yes= by default for all source blocks but if you manually put it there this breaks that assumption
and no source blocks will be tangled


* The simple stuff

apparently this makes things run faster (I found it [[https://nullprogram.com/blog/2016/12/22/][here]])
#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src

** Personal info

From ~GPG~ to ~git~ to email clients and snippets, the following seems kinda important to have around
#+begin_src emacs-lisp
(setq user-full-name "David Adams"
      user-mail-address "dbadams@iinet.net.au")
#+end_src

*** GPG
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

** Default settings

*** Common settings
Following in Tec's footsteps I somehow stumbled upon [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]] which gave some inspiration on better default settings

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t ; its rubbish bin not trash
 window-combination-resize t ; take all new space
 x-stretch-cursor t          ; deal with glyphs
 enable-local-variables t    ; I want to be able to use dir-locals
 )


(setq
 undo-limit 2000000
 evil-want-fine-undo t          ; make undo limit bigger
 auto-save-default t            ; help with the b-s
 truncate-string-ellipsis "…"   ; is nicer
 compilation-scroll-output t    ; warnings annoy me
)
#+end_src

***  Frame sizing

Creating a new full-size window each time we want a new frame does not seem ideal. Especially considering window managers
make it easy to snap windows into the correct place

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src


***  Window Splitting

I always want new windows to be to the right

#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src
and when I do I would like to be promoted for what buffer to switch to


#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

**  Doom Config

*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
You have probable seen a ~how to install~ section at the top of a bunch of emacs pages. Doom has it so that you remove a comment
and that's it. There are also extra features that can be added to some of the modules with a =+<somtehing>=

#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no

;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom! :input
       <<doom-input>>

        :completion
        <<doom-completion>>

        :ui
        <<doom-ui>>

        :editor
        <<doom-editor>>

        :term
        <<doom-term>>

        :checkers
        <<doom-checkers>>

        :tools
        <<doom-tools>>

        :os
        <<doom-os>>

        :lang
        <<doom-lang>>

        :email
        <<doom-email>>

        :app
        <<doom-app>>

        :config
        <<doom-config>>
) ;lol don't forget this closing brace like I did
#+end_src

**** Config's config

If you don't know what a literate configuration is, welcome! You are reading one.
Doom has some rather nice defaults for literate src_elisp{:config}
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Completion

#+name: doom-completion
#+begin_src emacs-lisp
(company            ; the ultimate code completion backend
 +childframe)       ; ... when the children are actually better
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;;(ivy
;; +icons                 ; a search engine for love and life
;;)
(vertico +icons)    ; search endine for the future
#+end_src

**** General UI

Some are doom specific whilst others are nice quality of life improvements

#+name: doom-ui
#+begin_src emacs-lisp
;;deft              ; notational velocity for Emacs
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
doom-quit         ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)  ; 🙂
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra
;;indent-guides     ; highlighted indent columns
(ligatures +extra)         ; ligatures and symbols to make your code pretty again
minimap           ; show a map of the code on the side
modeline          ; snazzy, Atom-inspired modeline, plus API
nav-flash         ; blink cursor line after big motions
;;neotree           ; a project drawer, like NERDTree for vim
ophints           ; highlight the region an operation acts on
(popup +defaults +all)   ; tame sudden yet inevitable temporary windows
(tabs +centaur-tabs)             ; a tab bar for Emacs and prettyer tabs
treemacs          ; a project drawer, like neotree but cooler
unicode           ; extended unicode support for various languages
vc-gutter         ; vcs diff in the fringe
vi-tilde-fringe   ; fringe tildes to mark beyond EOB
(window-select +numbers)    ; visually switch windows
workspaces        ; tab emulation, persistence & separate workspaces
zen               ; distraction-free coding or writing

#+end_src

**** Editor things

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
(format +onsave)  ; automated prettiness
;;god               ; run Emacs commands without modifier keys
;;lispy             ; vim for lisp, for people who don't like vim
multiple-cursors  ; editing in many places at once
;;objed             ; text object editing for the innocent
;;parinfer          ; turn lisp into python, sort of
;;rotate-text       ; cycle region at point between text candidates
snippets          ; my elves. They type so I don't have to
;;word-wrap         ; soft wrapping with language-aware indent

:emacs
(dired +icons)            ; making dired pretty [functional]
electric          ; smarter, keyword-based electric-indent
(ibuffer +icons)       ; interactive buffer management
undo              ; persistent, smarter undo for your inevitable mistakes
vc                ; version-control and Emacs, sitting in a tree
#+end_src

**** Terminals

whilst vterm is the best terminal emulator inside emacs currently, it is the most painful thing to compile (with
the exception of maybe pdftools). As such having alternatives can be useful

#+name: doom-term
#+begin_src emacs-lisp
eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell REPL for Emacs
;;term              ; basic terminal emulator for Emacs
vterm             ; the best terminal emulation in Emacs
#+end_src

**** Checkers

not much to be said. spell-fu seems good but the interfaces are not as nice
grammar would be much better if it offered suggestions on how to improve things (well specifically writegood mode)
#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
(:if (executable-find "aspell") (spell +flyspell +aspell +everywhere)) ; tasing you for misspelling mispelling
;;grammar           ; tasing grammar mistake every you make
#+end_src


**** Other stuff

despite the name herein lies some of the things that make emacs worth using.

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
;;debugger          ; FIXME stepping through code, to help you add bugs
;;direnv
docker
editorconfig      ; let someone else argue about tabs vs spaces
;;ein               ; tame Jupyter notebooks with emacs
(eval +overlay)     ; run code, run (also, repls)
;;gist              ; interacting with github gists
lookup              ; navigate your code and its documentation
lsp               ; M-x vscode
(magit +forge)    ; a git porcelain for Emacs
make              ; run make tasks from Emacs
;;pass              ; password manager for nerds
pdf               ; pdf enhancements
;;prodigy           ; FIXME managing external services & code builders
rgb               ; creating color strings
taskrunner        ; taskrunner for all your projects
;;terraform         ; infrastructure as code
tmux              ; an API for interacting with tmux
tree-sitter       ; syntax and parsing, sitting in a tree...
upload            ; map local to remote projects via ssh/ftp
#+end_src
#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)  ; improve compatibility with macOS
tty               ; improve the terminal Emacs experience
#+end_src


**** Languages

#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
(cc +lsp)                ; C > C++ == 1
clojure           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .NET, and mono shenanigans
data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;elixir            ; erlang done right
;;elm               ; care for a cup of TEA?
emacs-lisp        ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(graphql +lsp) ; Give queries a REST
;;(go +lsp)         ; the hipster dialect
;;(haskell +dante)  ; a language that's lazier than I am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
json              ; At least it ain't XML
(java +lsp) ; the poster child for carpal tunnel syndrome
(javascript +lsp)        ; all(hope(abandon(ye(who(enter(here))))))
;;(julia +lsp)             ; a better, faster MATLAB
;;kotlin            ; a better, slicker Java(Script)
;;latex             ; writing papers in Emacs has never been so fun
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
;;lua               ; one-based indices? one-based indices
markdown          ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
;;nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org
+pretty
+pandoc
+present
+jupyter)                                ; organize your plain life in plain text
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
(python +lsp +pyright +conda +cython)           ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rest              ; Emacs as a REST client
;;rst               ; ReST in peace
;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;(scheme +guile)   ; a fully conniving family of lisps
sh                ; she sells {ba,z,fi}sh shells on the C xor
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
web               ; the tubes
yaml              ; JSON, but readable
;;zig               ; C, but simpler
#+end_src


**** Bring it all in

A constant work in progress. But trying to understand it does teach you a bunch.

#+name: doom-email
#+begin_src emacs-lisp
(:if (executable-find "mu") (mu4e +gmail))
;;notmuch
;;(wanderlust +gmail)
#+end_src

there are other things to consider as well
#+name: doom-app
#+begin_src emacs-lisp
;;calendar
;;emms
everywhere        ; *leave* Emacs!? You must be joking
;;irc               ; how neckbeards socialize
;;(rss +org)        ; emacs as an RSS reader
;;twitter           ; twitter client https://twitter.com/vnought
#+end_src

**** Input

Whilst I could probably do japanese it would be a struggle so lets not
#+name: doom-input
#+begin_src emacs-lisp
;;bidi                       ; (tfel ot) thgir etirw uoy gnipleh
;;chinese
;;japanese
;;layout                     ; auie,ctsrnm is the superior home row
#+end_src

*** General Visual

**** Fonts

I am a big fan of 'Fira Code'. Font sizes do need some fiddling to get it all right.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Fira Code Nerd Font" :size 16)
      doom-big-font (font-spec :family "Fira Code Nerd Font" :size 24)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 24)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light)
      )

#+end_src

***** Missing Fonts

Warning about missing fonts is a bit of a problem especially if you are coming to a new system.
The following code (once again shamelessly ripped from Tec) makes it slightly more nice.
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts      '("Fira Code*" "Overpass" "JuliaMono" "IBM Plex Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts()>>
#+end_src
***** Fixing icons

Some icons such as       (should see a windows icon, up down arrows a clock and a calendar not rain clouds a rain drop or stars) can appear to be incorrect depending on what font doom uses for unicode rendering.
This can make things difficult if you are working on something that renders them differently.
#+begin_src emacs-lisp
    (setq doom-unicode-font (font-spec :family "Fira Code Nerd Font"))
#+end_src

**** Theme and modeline

I like the softer look of Nord and use it in a number of other places. There are some disadvantages like weird comments
but overall its nice.

#+begin_src emacs-lisp

(setq doom-theme 'doom-nord)

#+end_src

I use linux on all my systems so I don't need to be told that =LF UTF-8= is my file encoding all the time
 #+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
"We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
(setq-local doom-modeline-buffer-encoding
(unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                    '(coding-category-undecided coding-category-utf-8))
            (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)

(setq doom-modeline-minor-modes nil)
(setq doom-modeline-enable-word-count t) ; super nice in visual mode
 #+end_src



** Other stuff

*** Line numbers

I literally cannot function without relative lines numbers
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

*** Buffer names

Why not take advantage of icons for the default buffer
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "► Doom"
+doom-dashboard-name "► Doom")

#+end_src


*** Async config tangle

# TODO: update this
courtesy of Tec once again, as literate config files get big and tangling is blocking by default
having a simple async version seems like a good idea

#+begin_src emacs-lisp
(defvar +literate-tangle--proc nil)
(defvar +literate-tangle--proc-start-time nil)

(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (unless (getenv "__NOTANGLE")
    (let ((default-directory doom-private-dir))
      (when +literate-tangle--proc
        (message "Killing outdated tangle process...")
        (set-process-sentinel +literate-tangle--proc #'ignore)
        (kill-process +literate-tangle--proc)
        (sit-for 0.3)) ; ensure the message is seen for a bit
      (setq +literate-tangle--proc-start-time (float-time)
            +literate-tangle--proc
            (start-process "tangle-config"
                           (get-buffer-create " *tangle config*")
                           "emacs" "--batch" "--eval"
                           (format "(progn \
(require 'ox) \
(require 'ob-tangle) \
(setq org-confirm-babel-evaluate nil \
      org-inhibit-startup t \
      org-mode-hook nil \
      write-file-functions nil \
      before-save-hook nil \
      after-save-hook nil \
      vc-handled-backends nil \
      org-startup-folded nil \
      org-startup-indented nil) \
(org-babel-tangle-file \"%s\" \"%s\"))"
                                   +literate-config-file
                                   (expand-file-name (concat doom-module-config-file ".el")))))
      (set-process-sentinel +literate-tangle--proc #'+literate-tangle--sentinel)
      (run-at-time nil nil (lambda () (message "Tangling config.org"))) ; ensure shown after a save message
      "Tangling config.org...")))

(defun +literate-tangle--sentinel (process signal)
  (cond
   ((and (eq 'exit (process-status process))
         (= 0 (process-exit-status process)))
    (message "Tangled config.org sucessfully (took %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))
   ((memq (process-status process) (list 'exit 'signal))
    (+popup-buffer (get-buffer " *tangle config*"))
    (message "Failed to tangle config.org (after %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))))

(defun +literate-tangle-check-finished ()
  (when (and (process-live-p +literate-tangle--proc)
             (yes-or-no-p "Config is currently retangling, would you please wait a few seconds?"))
    (switch-to-buffer " *tangle config*")
    (signal 'quit nil)))
(add-hook! 'kill-emacs-hook #'+literate-tangle-check-finished)

#+end_src



*** Splash screen

re-occurring pain point as this is the first thing that you see when you open emacs. Finding both the right image at the right size and colour is difficult.
At the moment it is simple but I have bigger plans

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/blackhole-lines.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")
(defvar fancy-splash-image-nil
  (expand-file-name "misc/splash-images/transparent-pixel.png" doom-private-dir)
  "An image to use at minimum size, usually a transparent pixel")

(setq fancy-splash-sizes
      `((:height 500 :min-height 50 :padding (0 . 2) :template ,(expand-file-name "misc/splash-images/blackhole-lines-0.svg" doom-private-dir))
        (:height 440 :min-height 42 :padding (1 . 4) :template ,(expand-file-name "misc/splash-images/blackhole-lines-0.svg" doom-private-dir))
        (:height 400 :min-height 38 :padding (1 . 4) :template ,(expand-file-name "misc/splash-images/blackhole-lines-1.svg" doom-private-dir))
        (:height 350 :min-height 36 :padding (1 . 3) :template ,(expand-file-name "misc/splash-images/blackhole-lines-2.svg" doom-private-dir))
        (:height 300 :min-height 34 :padding (1 . 3) :template ,(expand-file-name "misc/splash-images/blackhole-lines-3.svg" doom-private-dir))
        (:height 250 :min-height 32 :padding (1 . 2) :template ,(expand-file-name "misc/splash-images/blackhole-lines-4.svg" doom-private-dir))
        (:height 200 :min-height 30 :padding (1 . 2) :template ,(expand-file-name "misc/splash-images/blackhole-lines-5.svg" doom-private-dir))
        (:height 100 :min-height 24 :padding (1 . 2) :template ,(expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir))
        (:height 0   :min-height 0  :padding (0 . 0) :file ,fancy-splash-image-nil)))

(defvar fancy-splash-sizes
  `((:height 500 :min-height 50 :padding (0 . 2))
    (:height 440 :min-height 42 :padding (1 . 4))
    (:height 330 :min-height 35 :padding (1 . 3))
    (:height 200 :min-height 30 :padding (1 . 2))
    (:height 0   :min-height 0  :padding (0 . 0) :file ,fancy-splash-image-nil))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . warning) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :file)
                                       (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src
*** Systemd daemon

for a lot of things it makes sense to run emacs as a daemon. Especially mail.
#+name: emacsclient service
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

which is then enabled by
#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

So to enable =mu4e= when actually running the daemon. Unfortunate that =circle= also cannot be started at this time.
Also make sure to switch to the dashboard.

#+name: daemon initialisation
#+begin_src emacs-lisp (if not((executable-find "mu")) ":tangle no")

(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (+mu4e-lock-add-watcher)
    (when (+mu4e-lock-available t)
      (mu4e~start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft\\|\\*stdin\\|emacs-everywhere" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src


*** Full screen

The majority of screens that I work on are 1080p so having emacs full screen by default is nice for them.
Should I switch to higher resolution displays this will likely become system dependent.
#+begin_src emacs-lisp
;; auto fullscreen
(if (eq initial-window-system 'x)                 ; if started by emacs command or desktop file
    (toggle-frame-maximized)
  (toggle-frame-fullscreen))
#+end_src
#TODO: make this work with wayland


*** Dashboard quick actions

There are only a few things I do on the dashboard. So why not make them quicker and save keystrokes

#+begin_src emacs-lisp
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ne "f" #'find-file
        :desc "Recent files" :ne "r" #'consult-recent-file
        :desc "Config dir" :ne "C" #'doom/open-private-config
        :desc "Open config.org" :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ne "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ne "n" #'org-roam-node-find
        :desc "Switch buffer" :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer" :ne "i" #'ibuffer
        :desc "Open Project" :ne "p" #'projectile-switch-project
        :desc "Open Mail" :ne "m" #'mu4e
        :desc "Set theme" :ne "t" #'consult-theme
        :desc "Quit" :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ne "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

* Packages
** Loading instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Whilst doom provides most of what you will need if you are a package developer or need to get the absolute latest thing due to features or instability
there is a nice and simple way of doing so:  the ~package!~ macro in  =packages.el=.
~doom sync~ will need to be run afterwards.
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src


*** From MEPLA/EPLA/emacsmirror

For ~a-thing~ do:
#+begin_src emacs-lisp
(package! a-thing)
#+end_src

*** From GIT

As a reminder for me, to install something from a git repo use ~:recipe~ and documentation
can be found [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! some-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If there isn't a ~PACKAGENAME.el~ or its in a weird place use ~:files~.
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_SRC

*** Disable defaults

You can get rid of the defaults:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src

You can overwrite the defaults
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

It should be noted that Doom will fill in the rest of ~:recipe~ so you don't have to!

You can even override with a specific branch:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src


** Convenience

*** Avy

Apparently this is not enabled by default and I like going to multiple places
#+begin_src emacs-lisp
(setq avy-all-windows 'all-frames)
#+end_src

*** Evil-escape

Evil escape is disabled in ~vterm-mode~ by default. I dislike this so I will keep
all the defaults excepting it.
#+begin_src emacs-lisp
(setq evil-escape-excluded-major-modes '(neotree-mode treemacs-mode))
#+end_src

*** Ligatures


Ligature's are still an issue for me. Especially python. So I have done a bit of a blanket ignore
till I figure out what I want
#+begin_src emacs-lisp
(setq +ligatures-extras-in-modes '(elisp-mode org-mode))
(setq +ligatures-in-modes '(not special-mode comint-mode eshell-mode term-mode vterm-mode Info-mode python-mode))
#+end_src


*** Which-key

I don't know why this is not enabled by default, but I like being able to navigate multiple pages.
Especially if I have looked it up with =SPC h b t=.
#+begin_src emacs-lisp
(setq which-key-use-C-h-commands 't)
#+end_src

*** vterm

I like to use tmux inside vterm and use vim bindings for navigating panes and windows.
This simply disables the global =C-h= for help.
#+begin_src emacs-lisp
(map! :after vterm
        :map vterm-mode-map
        "C-a" #'vterm-send-C-a
        "C-h" #'vterm-send-C-h)
#+end_src

** Tools


*** Very Large files

title is self explanatory. Why not chunk files?
#+begin_src emacs-lisp
;; (package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
;;   :pin "cc02f2533782d6b9b628cec7e2dcf25b2d05a27c" :disable t)
#+end_src
as it is something I use infrequently I don't want it to delay start up
#+begin_src emacs-lisp
;; (use-package! vlf-setup
;;   :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

*** Eros

#+begin_quote
 =:tools eval=
#+end_quote

Provides amazing inline evaluation of ~elisp~ using =gr= and =gR=.
Another gem from Tec's config is to make this look better
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ") ; default =>
#+end_src

*** Evil

#+begin_quote
=:editor evil=
#+end_quote

Doom's configuration of evil is reasonable and pragmatic.
However everyone has some personal preferences.
#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

*** Magit

automated commit templates seem nice to me
#+begin_src emacs-lisp
(defvar +magit-project-commit-templates-alist nil
  "Alist of toplevel dirs and template strings/functions.")
(after! magit
  (defun +magit-fill-in-commit-template ()
    "Insert template from `+magit-fill-in-commit-template' if applicable."
    (when-let ((template (and (save-excursion (goto-char (point-min)) (string-match-p "\\`\\s-*$" (thing-at-point 'line)))
                              (cdr (assoc (file-name-base (directory-file-name (magit-toplevel)))
                                          +magit-project-commit-templates-alist)))))
      (goto-char (point-min))
      (insert (if (stringp template) template (funcall template)))
      (goto-char (point-min))
      (end-of-line)))
  (add-hook 'git-commit-setup-hook #'+magit-fill-in-commit-template 90)
                )

(after! magit
(add-to-list '+magit-project-commit-templates-alist (cons "first" (lambda () (insert (magit-get-current-branch) ": "))))
  )
#+end_src

TODO: handle automated setup
I have yet to find something I want to change about magit. Maybe magit delta can be put to use.
#+begin_src emacs-lisp

;; (after! magit
;;   (magit-delta-mode +1))

#+end_src

*** Company

I both love and hate company. It make emacs better than any vim plugin system, but is also
the thing that is most likely going to slow down my typing experience.

#+begin_src emacs-lisp
(after! company
  (setq company-minimum-prefix-length 2)
  (setq company-show-numbers t))
#+end_src

Also a good idea to improve memory:
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

**** LSP optimisation

the following can help to see if its the language server or company that is slow.
Its almost always garbage collection though.
#+begin_src emacs-lisp
(setq company-idle-delay 0.01)
#+end_src

**** Plain text defaults

Having ~Ispell~ Enabled is really useful.

#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src

**** ESS

Nothing to put here currently. Look into ~company-dabbrev-code~

*** Projectile

because it faster
#+begin_src emacs-lisp
(setq projectile-indexing-method 'native)
#+end_src
*** Smerge
The default keybindings are not the best really, and could use some improvement.
Especially in keeping all changes.
#+begin_src emacs-lisp
(defun smerge-repeatedly ()
  "Perform smerge actions again and again"
  (interactive)
  (smerge-mode 1)
  (smerge-transient))
(after! transient
  (transient-define-prefix smerge-transient ()
    [["Move"
      ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (evil-scroll-line-to-center (line-number-at-pos)) (smerge-repeatedly)))
      ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev))(evil-scroll-line-to-center (line-number-at-pos)) (smerge-repeatedly)))]
     ["Keep"
      ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
      ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
      ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
      ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
      ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
     ["Diff"
      ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
      ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
      (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
      ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
      ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
     ["Other"
      ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
      ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
      ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
      ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

Oh and I also want to bind this to a reasonable key.
#+begin_src emacs-lisp
(after! magit
  (map! :leader
        (:prefix-map ("g" . "git")
         "m" 'smerge-repeatedly)))
#+end_src

*** Flycheck

because the default bindings are kinda dumb so everything is now =SPC c x=
#+begin_src emacs-lisp
(after! flycheck
  (map! :leader
        (:prefix-map ("c" . "code")
         "x" flycheck-command-map)))
#+end_src

*** Ispell

SCOWL provides a nice place to get dictionaries from I would like one:

- size
    80 (huge)
- spellings
    British(-ise) and Australian
- spelling variants level
    0
- diacritics
    keep
- extra lists
    hacker, roman


**** Aspell

#+begin_src shell :tangle no
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && sudo make install
#+end_src


**** Configuration

Actually set the correct spelling dictionary
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src

Also having a personal dictionary that is separate from the original is useful

#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src

*** YASnippet

nested snippets are good so:
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

** Visuals

*** Info Colors

Drew Adams =info+= package is really nice but having nice colours is even better.
#+begin_src emacs-lisp :tangle packages.el
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src

simply hook into =info=

#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

*** Theme magic

Themes are sometimes hard to match in terminals especially given settings. This is a way of helping this.

#+begin_src emacs-lisp :tangle packages.el
(package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

# This operates using =pywal=, which is present in some repositories, but most
# reliably installed with =pip=.
# #+begin_src shell :eval no :tangle (if (executable-find "wal") "no" "setup.sh")
# sudo python3 -m pip install pywal
# #+end_src
Theme magic selects 8 reasonable colours to use from font faces and other data.
Unfortunately those 8 colours are used for both normal and light variants.
Fortunately =doom-themes= makes things more easy as we can use the colour utils
to generate sensible variations.

#+begin_src emacs-lisp
(use-package! theme-magic
  :commands theme-magic-from-emacs
  :config
  (defadvice! theme-magic--auto-extract-16-doom-colors ()
    :override #'theme-magic--auto-extract-16-colors
    (list
     (face-attribute 'default :background)
     (doom-color 'error)
     (doom-color 'success)
     (doom-color 'type)
     (doom-color 'keywords)
     (doom-color 'constants)
     (doom-color 'functions)
     (face-attribute 'default :foreground)
     (face-attribute 'shadow :foreground)
     (doom-blend 'base8 'error 0.1)
     (doom-blend 'base8 'success 0.1)
     (doom-blend 'base8 'type 0.1)
     (doom-blend 'base8 'keywords 0.1)
     (doom-blend 'base8 'constants 0.1)
     (doom-blend 'base8 'functions 0.1)
     (face-attribute 'default :foreground))))
#+end_src
*** Emojify

Sometimes the emoji is used over the actual character when we really want the actual character. Espeically in org mode and vterm.
#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀"
    ;; I just want to see this as text
    "©" "™")
  "Characters that should never be affected by `emojify-mode'.")


(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

** File Types

*** Systemd
#+begin_src emacs-lisp :tangle packages.el
(package! systemd)
#+end_src

#+begin_src emacs-lisp
(use-package! systemd
  :defer t)
#+end_src

* Applications

** Mail
*** Fetching
**** Rebuild mail index whilst using mu4e
#+begin_src emacs-lisp (if not((executable-find "mu")) ":tangle no")
(after! mu4e
  (defvar mu4e-reindex-request-file "/tmp/mu_reindex_now"
    "Location of the reindex request, signaled by existance")
  (defvar mu4e-reindex-request-min-seperation 5.0
    "Don't refresh again until this many second have elapsed.
Prevents a series of redisplays from being called (when set to an appropriate value)")

  (defvar mu4e-reindex-request--file-watcher nil)
  (defvar mu4e-reindex-request--file-just-deleted nil)
  (defvar mu4e-reindex-request--last-time 0)

  (defun mu4e-reindex-request--add-watcher ()
    (setq mu4e-reindex-request--file-just-deleted nil)
    (setq mu4e-reindex-request--file-watcher
          (file-notify-add-watch mu4e-reindex-request-file
                                 '(change)
                                 #'mu4e-file-reindex-request)))

  (defadvice! mu4e-stop-watching-for-reindex-request ()
    :after #'mu4e~proc-kill
    (if mu4e-reindex-request--file-watcher
        (file-notify-rm-watch mu4e-reindex-request--file-watcher)))

  (defadvice! mu4e-watch-for-reindex-request ()
    :after #'mu4e~proc-start
    (mu4e-stop-watching-for-reindex-request)
    (when (file-exists-p mu4e-reindex-request-file)
      (delete-file mu4e-reindex-request-file))
    (mu4e-reindex-request--add-watcher))

  (defun mu4e-file-reindex-request (event)
    "Act based on the existance of `mu4e-reindex-request-file'"
    (if mu4e-reindex-request--file-just-deleted
        (mu4e-reindex-request--add-watcher)
      (when (equal (nth 1 event) 'created)
        (delete-file mu4e-reindex-request-file)
        (setq mu4e-reindex-request--file-just-deleted t)
        (mu4e-reindex-maybe t))))

  (defun mu4e-reindex-maybe (&optional new-request)
    "Run `mu4e~proc-index' if it's been more than
`mu4e-reindex-request-min-seperation'seconds since the last request,"
    (let ((time-since-last-request (- (float-time)
                                      mu4e-reindex-request--last-time)))
      (when new-request
        (setq mu4e-reindex-request--last-time (float-time)))
      (if (> time-since-last-request mu4e-reindex-request-min-seperation)
          (mu4e~proc-index nil t)
        (when new-request
          (run-at-time (* 1.1 mu4e-reindex-request-min-seperation) nil
                       #'mu4e-reindex-maybe))))))
#+end_src

**** Config Conversions
***** mbsync to imapnotify

When run without flags this will perform the following actions
+ Read, and parse [[file:~/.mbsyncrc][~/.mbsyncrc]], specifically recognising the following properties
  - ~IMAPAccount~
  - ~Host~
  - ~Port~
  - ~User~
  - ~Password~
  - ~PassCmd~
  - ~Patterns~
+ Call ~mbsync --list ACCOUNT~, and filter results according to ~Patterns~
+ Construct a imapnotify config for each account, with the following hooks
  - onNewMail :: src_shell{mbsync --pull ACCOUNT:MAILBOX}
  - onNewMailPost :: src_shell{if mu index --lazy-check; then test -f /tmp/mu_reindex_now && rm /tmp/mu_reindex_now; else touch /tmp/mu_reindex_now; fi}
+ Compare accounts list to previous accounts, enable/disable the relevant
  systemd services, called with the ~--now~ flag (start/stop services as well)

This script also supports the following flags
+ ~--status~ to get the status of the relevant systemd services supports =active=,
  =failing=, and =disabled=
+ ~--enable~ to enable all relevant systemd services
+ ~--disable~ to disable all relevant systemd services
#+begin_src python :tangle misc/mbsync-imapnotify.py :shebang "#!/usr/bin/env python3"
from pathlib import Path
import json
import re
import shutil
import subprocess
import sys
import fnmatch

mbsyncFile = Path("~/.mbsyncrc").expanduser()

imapnotifyConfigFolder = Path("~/.config/imapnotify/").expanduser()
imapnotifyConfigFolder.mkdir(exist_ok=True)
imapnotifyConfigFilename = "notify.conf"

imapnotifyDefault = {
    "host": "",
    "port": 993,
    "tls": True,
    "tlsOptions": {"rejectUnauthorized": True},
    "onNewMail": "",
    "onNewMailPost": "if mu index --lazy-check; then test -f /tmp/mu_reindex_now && rm /tmp/mu_reindex_now; else touch /tmp/mu_reindex_now; fi",
}


def stripQuotes(string):
    if string[0] == '"' and string[-1] == '"':
        return string[1:-1].replace('\\"', '"')


mbsyncInotifyMapping = {
    "Host": (str, "host"),
    "Port": (int, "port"),
    "User": (str, "username"),
    "Password": (str, "password"),
    "PassCmd": (stripQuotes, "passwordCmd"),
    "Patterns": (str, "_patterns"),
}

oldAccounts = [d.name for d in imapnotifyConfigFolder.iterdir() if d.is_dir()]

currentAccount = ""
currentAccountData = {}

successfulAdditions = []


def processLine(line):
    newAcc = re.match(r"^IMAPAccount ([^#]+)", line)

    linecontent = re.sub(r"(^|[^\\])#.*", "", line).split(" ", 1)
    if len(linecontent) != 2:
        return

    parameter, value = linecontent

    if parameter == "IMAPAccount":
        if currentAccountNumber > 0:
            finaliseAccount()
        newAccount(value)
    elif parameter in mbsyncInotifyMapping.keys():
        parser, key = mbsyncInotifyMapping[parameter]
        currentAccountData[key] = parser(value)
    elif parameter == "Channel":
        currentAccountData["onNewMail"] = f"mbsync --pull --new {value}:'%s'"


def newAccount(name):
    global currentAccountNumber
    global currentAccount
    global currentAccountData
    currentAccountNumber += 1
    currentAccount = name
    currentAccountData = {}
    print(f"\n\033[1;32m{currentAccountNumber}\033[0;32m - {name}\033[0;37m")


def accountToFoldername(name):
    return re.sub(r"[^A-Za-z0-9]", "", name)


def finaliseAccount():
    if currentAccountNumber == 0:
        return

    global currentAccountData
    try:
        currentAccountData["boxes"] = getMailBoxes(currentAccount)
    except subprocess.CalledProcessError as e:
        print(
            f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
            + f"`{' '.join(e.cmd)}' returned code {e.returncode}\033[0;37m"
        )
        return
    except subprocess.TimeoutExpired as e:
        print(
            f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
            + f"`{' '.join(e.cmd)}' timed out after {e.timeout:.2f} seconds\033[0;37m"
        )
        return

    if "_patterns" in currentAccountData:
        currentAccountData["boxes"] = applyPatternFilter(
            currentAccountData["_patterns"], currentAccountData["boxes"]
        )

    # strip not-to-be-exported data
    currentAccountData = {
        k: currentAccountData[k] for k in currentAccountData if k[0] != "_"
    }

    parametersSet = currentAccountData.keys()
    currentAccountData = {**imapnotifyDefault, **currentAccountData}
    for key, val in currentAccountData.items():
        valColor = "\033[0;33m" if key in parametersSet else "\033[0;37m"
        print(f"  \033[1;37m{key:<13} {valColor}{val}\033[0;37m")

    if (
            len(currentAccountData["boxes"]) > 15
            and "@gmail.com" in currentAccountData["username"]
    ):
        print(
            "  \033[1;31mWarning:\033[0;31m Gmail raises an error when more than"
            + "\033[1;31m15\033[0;31m simultanious connections are attempted."
            + "\n           You are attempting to monitor "
            + f"\033[1;31m{len(currentAccountData['boxes'])}\033[0;31m mailboxes.\033[0;37m"
        )

    configFile = (
        imapnotifyConfigFolder
        / accountToFoldername(currentAccount)
        / imapnotifyConfigFilename
    )
    configFile.parent.mkdir(exist_ok=True)

    json.dump(currentAccountData, open(configFile, "w"), indent=2)
    print(f" \033[0;35mConfig generated and saved to {configFile}\033[0;37m")

    global successfulAdditions
    successfulAdditions.append(accountToFoldername(currentAccount))


def getMailBoxes(account):
    boxes = subprocess.run(
        ["mbsync", "--list", account], check=True, stdout=subprocess.PIPE, timeout=10.0
    )
    return boxes.stdout.decode("utf-8").strip().split("\n")


def applyPatternFilter(pattern, mailboxes):
    patternRegexs = getPatternRegexes(pattern)
    return [m for m in mailboxes if testPatternRegexs(patternRegexs, m)]


def getPatternRegexes(pattern):
    def addGlob(b):
        blobs.append(b.replace('\\"', '"'))
        return ""

    blobs = []
    pattern = re.sub(r' ?"([^"]+)"', lambda m: addGlob(m.groups()[0]), pattern)
    blobs.extend(pattern.split(" "))
    blobs = [
        (-1, fnmatch.translate(b[1::])) if b[0] == "!" else (1, fnmatch.translate(b))
        for b in blobs
    ]
    return blobs


def testPatternRegexs(regexCond, case):
    for factor, regex in regexCond:
        if factor * bool(re.match(regex, case)) < 0:
            return False
    return True


def processSystemdServices():
    keptAccounts = [acc for acc in successfulAdditions if acc in oldAccounts]
    freshAccounts = [acc for acc in successfulAdditions if acc not in oldAccounts]
    staleAccounts = [acc for acc in oldAccounts if acc not in successfulAdditions]

    if keptAccounts:
        print(f"\033[1;34m{len(keptAccounts)}\033[0;34m kept accounts:\033[0;37m")
        restartAccountSystemdServices(keptAccounts)

    if freshAccounts:
        print(f"\033[1;32m{len(freshAccounts)}\033[0;32m new accounts:\033[0;37m")
        enableAccountSystemdServices(freshAccounts)
    else:
        print(f"\033[0;32mNo new accounts.\033[0;37m")

    notActuallyEnabledAccounts = [
        acc for acc in successfulAdditions if not getAccountServiceState(acc)["enabled"]
    ]
    if notActuallyEnabledAccounts:
        print(
            f"\033[1;32m{len(notActuallyEnabledAccounts)}\033[0;32m accounts need re-enabling:\033[0;37m"
        )
        enableAccountSystemdServices(notActuallyEnabledAccounts)

    if staleAccounts:
        print(f"\033[1;33m{len(staleAccounts)}\033[0;33m removed accounts:\033[0;37m")
        disableAccountSystemdServices(staleAccounts)
    else:
        print(f"\033[0;33mNo removed accounts.\033[0;37m")


def enableAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;32m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "enable", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;32m enabled")


def disableAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;33m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "disable", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;33m disabled")


def restartAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;34m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "restart", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;34m restarted")


def setSystemdServiceState(state, service):
    try:
        enabler = subprocess.run(
            ["systemctl", "--user", state, service, "--now"],
            check=True,
            stderr=subprocess.DEVNULL,
            timeout=5.0,
        )
        return True
    except subprocess.CalledProcessError as e:
        print(
            f" \033[1;31mfailed\033[0;31m to {state}, `{' '.join(e.cmd)}'"
            + f"returned code {e.returncode}\033[0;37m"
        )
    except subprocess.TimeoutExpired as e:
        print(f" \033[1;31mtimed out after {e.timeout:.2f} seconds\033[0;37m")
        return False


def getAccountServiceState(account):
    return {
        state: bool(
            1
            - subprocess.run(
                [
                    "systemctl",
                    "--user",
                    f"is-{state}",
                    "--quiet",
                    f"goimapnotify@{accountToFoldername(account)}.service",
                ],
                stderr=subprocess.DEVNULL,
            ).returncode
        )
        for state in ("enabled", "active", "failing")
    }


def getAccountServiceStates(accounts):
    for account in accounts:
        enabled, active, failing = getAccountServiceState(account).values()
        print(f"  - \033[1;37m{account:<18}\033[0;37m ", end="", flush=True)
        if not enabled:
            print("\033[1;33mdisabled\033[0;37m")
        elif active:
            print("\033[1;32mactive\033[0;37m")
        elif failing:
            print("\033[1;31mfailing\033[0;37m")
        else:
            print("\033[1;35min an unrecognised state\033[0;37m")


if len(sys.argv) > 1:
    if sys.argv[1]   in ["-e", "--enable"]:
        enableAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-d", "--disable"]:
        disableAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-r", "--restart"]:
        restartAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-s", "--status"]:
        getAccountServiceStates(oldAccounts)
        exit()
    elif sys.argv[1] in ["-h", "--help"]:
        print("""\033[1;37mMbsync to IMAP Notify config generator.\033[0;37m

Usage: mbsync-imapnotify [options]

Options:
    -e, --enable       enable all services
    -d, --disable      disable all services
    -r, --restart      restart all services
    -s, --status       fetch the status for all services
    -h, --help         show this help
""", end='')
        exit()
    else:
        print(f"\033[0;31mFlag {sys.argv[1]} not recognised, try --help\033[0;37m")
        exit()


mbsyncData = open(mbsyncFile, "r").read()

currentAccountNumber = 0

totalAccounts = len(re.findall(r"^IMAPAccount", mbsyncData, re.M))


def main():
    print("\033[1;34m:: MbSync to Go IMAP notify config file creator ::\033[0;37m")

    shutil.rmtree(imapnotifyConfigFolder)
    imapnotifyConfigFolder.mkdir(exist_ok=False)
    print("\033[1;30mImap Notify config dir purged\033[0;37m")

    print(f"Identified \033[1;32m{totalAccounts}\033[0;32m accounts.\033[0;37m")

    for line in mbsyncData.split("\n"):
        processLine(line)

    finaliseAccount()

    print(
        f"\nConfig files generated for \033[1;36m{len(successfulAdditions)}\033[0;36m"
        + f" out of \033[1;36m{totalAccounts}\033[0;37m accounts.\n"
    )

    processSystemdServices()


if __name__ == "__main__":
    main()
#+end_src

***** mbsync to msmtp

#+begin_src python :tangle misc/mbsync-msmtp.py :shebang "#!/usr/bin/env python3"
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List
import json
import shutil
import os


mbsyncFile = Path("~/.mbsyncrc").expanduser()
msmtpFile = Path("~/.msmtprc").expanduser()
default_port = 587
field_map = {
    "name": "account",
    "host": "host",
    "port": "port",
    "from_address": "from",
    "user": "user",
    "password_expression": "passwordeval",
}

msmtpDefaults = {
    "defaults": "",
    "auth": "on",
    "tls": "on",
    "tls_trust_file": "/etc/ssl/certs/ca-certificates.crt",
    "logfile" :"~/.msmtp.log",
}

def export_defaults(defaults):
    return "\n".join(f"{field:<20}{value}" for field,value in msmtpDefaults.items())

@dataclass(init=False)
class MsmtpAccount:
    name: str = ""
    host: str = ""
    port: int = 0
    from_address: str = ""
    user: str = ""
    password_expression: str = ""

    def export(self):
        return "\n".join([f"{field_map[field]:<20}{value}" for field,value in asdict(self).items()])


accounts: List[MsmtpAccount] = []

def parse_mbsync_file():
    cur = None
    with open(mbsyncFile, "r") as f:
        for line in f:
            if(line.startswith("IMAPAccount")):
                accounts.append(cur)
                cur= MsmtpAccount()
                cur.name = line.strip().split()[1]
                cur.port = default_port
            if(line.startswith("Host")):
                cur.host = line.strip().split()[1].replace("imap", "smtp")
            if(line.startswith("User")):
                cur.from_address = line.strip().split()[1]
                cur.user = cur.from_address.split("@")[0]
            if(line.startswith("PassCmd")):
                cur.password_expression = " ".join(line.strip().split()[1:])
    accounts.append(cur)

def write_file():
    with open(msmtpFile, "w") as f:
        f.write(export_defaults(msmtpDefaults)+"\n\n")
        for acct in accounts:
            if(acct != None):
                f.write(acct.export()+"\n\n")
        f.write(f"account default : {accounts[1].name}")

def main():
    print("\033[1;34m:: MbSync to msmtp config file creator ::\033[0;37m")

    shutil.move(msmtpFile, msmtpFile.with_suffix(".old"))
    print("\033[1;30msmtp config file moved to .msmtprc.old\033[0;37m")

    parse_mbsync_file()
    write_file()
    print("\033[1;34m Complete \033[0;37m")


if __name__ == "__main__":
    main()

#+end_src
**** Systemd Services
A template service file so we can enable a unit per-account.
#+begin_src systemd :tangle ~/.config/systemd/user/goimapnotify@.service
[Unit]
Description=IMAP notifier using IDLE, golang version.
ConditionPathExists=%h/.config/imapnotify/%I/notify.conf
After=network.target

[Service]
ExecStart=/usr/bin/goimapnotify -conf %h/.config/imapnotify/%I/notify.conf
Restart=always
RestartSec=30

[Install]
WantedBy=default.target
#+end_src

Enabling the service is actually taken care of by that python script.

#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync.timer" "no")
[Unit]
Description=call mbsync on all accounts every 5 minutes
ConditionPathExists=%h/.mbsyncrc

[Timer]
OnBootSec=5m
OnUnitInactiveSec=5m

[Install]
WantedBy=default.target
#+end_src

#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync.service" "no")
[Unit]
Description=mbsync service, sync all mail
Documentation=man:mbsync(1)
ConditionPathExists=%h/.mbsyncrc

[Service]
Type=oneshot
ExecStart=/usr/bin/mbsync -c %h/.mbsyncrc --all

[Install]
WantedBy=mail.target
#+end_src

Enabling (and starting) this is as simple as
#+begin_src shell :tangle (if (or (not (executable-find "mu")) (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled mbsync.timer"))) "no" "setup.sh")
systemctl --user enable mbsync.timer --now
#+end_src


#TODO: put something in setup script to deal with this and put in right place

its a bit buggy tbh
#+begin_src systemd :tangle (if (executable-find "mu") "~/.config/systemd/user/mbsync-resume.service" "no")
[Unit]
Description=sync mail after resume
Documentation=man:mbsync(1)
Requires=network-online.target
After=network-online.target suspend.target

[Service]
Type=simple
# Environment="HOME=/home/dadams"
ExecStartPre=/bin/sleep 10
User=dadams
ExecStart=/usr/bin/mbsync -c /home/dadams/.mbsyncrc --all

[Install]
WantedBy=suspend.target
#+end_src

*** Indexing
*** Sending
*** Mu4e
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref mu4e-conf
:END:

This is here because of some weird ass property drawer errors
#+begin_src emacs-lisp :noweb no-export (if (executable-find "mu") ":tangle yes") :noweb-ref nil
(after! mu4e
  <<mu4e-conf>>
)
#+end_src

**** Config
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref mu4e-conf
:END:

***** Viewing Mail
Browser good for rendering not good for email applications.

To account for the increase width of each flag character, and make perform a
few more visual tweaks, we'll tweak the headers a bit

#+begin_src emacs-lisp
(setq mu4e-headers-fields
      '((:flags . 6)
        (:account-stripe . 2)
        (:from-or-to . 25)
        (:folder . 10)
        (:recipnum . 2)
        (:subject . 80)
        (:human-date . 8))
      +mu4e-min-header-frame-width 142
      mu4e-headers-date-format "%d/%m/%y"
      mu4e-headers-time-format "⧖ %H:%M"
      mu4e-headers-results-limit 1000
      mu4e-index-cleanup t)

(add-to-list 'mu4e-bookmarks
             '(:name "Yesterday's messages" :query "date:2d..1d" :key ?y) t)

(defvar +mu4e-header--folder-colors nil)
(appendq! mu4e-header-info-custom
          '((:folder .
             (:name "Folder" :shortname "Folder" :help "Lowest level folder" :function
              (lambda (msg)
                (+mu4e-colorize-str
                 (replace-regexp-in-string "\\`.*/" "" (mu4e-message-field msg :maildir))
                 '+mu4e-header--folder-colors))))))
#+end_src
We'll also use a nicer alert icon
#+begin_src emacs-lisp
;; (setq mu4e-alert-icon "/usr/share/icons/Papirus/64x64/apps/evolution.svg")
#+end_src
****** Contexts

These be important
#+begin_src emacs-lisp
(setq mu4e-context-policy 'pick-first)
(setq mu4e-compose-context-policy 'always-ask)
(load! "private/email.el")
#+end_src
***** Sending Mail
Let's send emails too.
#+begin_src emacs-lisp
(setq sendmail-program "/usr/bin/msmtp"
      send-mail-function #'smtpmail-send-it
      message-sendmail-f-is-evil t
      message-sendmail-extra-arguments '("--read-envelope-from"); , "--read-recipients")
      message-send-mail-function #'message-send-mail-with-sendmail)
#+end_src

We also want to define ~mu4e-compose-from-mailto~.

#+begin_src emacs-lisp
(defun mu4e-compose-from-mailto (mailto-string &optional quit-frame-after)
  (require 'mu4e)
  (unless mu4e~server-props (mu4e t) (sleep-for 0.1))
  (let* ((mailto (message-parse-mailto-url mailto-string))
         (to (cdr (assoc "To" mailto)))
         (subject (or (cdr (assoc "Subject" mailto)) ""))
         (body (cdr (assoc "Body" mailto)))
         (headers (-filter (lambda (spec) (not (-contains-p '("To" "Subject" "Body") (car spec)))) mailto)))
    (when-let ((mu4e-main (get-buffer mu4e-main-buffer-name)))
      (switch-to-buffer mu4e-main))
    (mu4e~compose-mail to subject headers)
    (when body
      (goto-char (point-min))
      (if (eq major-mode 'org-msg-edit-mode)
          (org-msg-goto-body)
        (mu4e-compose-goto-bottom))
      (insert body))
    (goto-char (point-min))
    (cond ((null to) (search-forward "To: "))
          ((string= "" subject) (search-forward "Subject: "))
          (t (if (eq major-mode 'org-msg-edit-mode)
                 (org-msg-goto-body)
               (mu4e-compose-goto-bottom))))
    (font-lock-ensure)
    (when evil-normal-state-minor-mode
      (evil-append 1))
    (when quit-frame-after
      (add-hook 'kill-buffer-hook
                `(lambda ()
                   (when (eq (selected-frame) ,(selected-frame))
                     (delete-frame)))))))
#+end_src

It would also be nice to change the name pre-filled in =From:= when drafting.
#+begin_src emacs-lisp
(defvar mu4e-from-name "David"
  "Name used in \"From:\" template.")
(defadvice! mu4e~draft-from-construct-renamed (orig-fn)
  "Wrap `mu4e~draft-from-construct-renamed' to change the name."
  :around #'mu4e~draft-from-construct
  (let ((user-full-name mu4e-from-name))
    (funcall orig-fn)))
#+end_src

We can also use this a signature,

#+begin_src emacs-lisp
(setq message-signature mu4e-from-name)
#+end_src

***** some visual improvements

just makes the icons slightly better for unicode fonts
#+begin_src emacs-lisp
  (cl-flet* ((make-help-button (text help-echo)
                               (with-temp-buffer
                                 (insert-text-button text
                                                     'help-echo help-echo
                                                     'mouse-face nil)
                                 (buffer-string)))
             (make-help-button-cons (text1 text2 help-echo)
                                    (cons (make-help-button text1 help-echo)
                                          (make-help-button text2 help-echo))))
    (setq mu4e-headers-threaded-label
          (make-help-button-cons "T" (concat " " (all-the-icons-octicon "git-branch" :v-adjust 0.05))
                                 "Thread view")
          mu4e-headers-related-label
          (make-help-button-cons "R" (concat " " (all-the-icons-material "link" :v-adjust -0.1))
                                 "Showing related emails")
          mu4e-headers-full-label
          (make-help-button-cons "F" (concat " " (all-the-icons-material "disc_full"))
                                 "Search is full!")))
#+end_src

* Languages

** Python

#+begin_src emacs-lisp
(after! conda
  (setq conda-anaconda-home (expand-file-name "/opt/miniconda3/")
        conda-env-home-directory (expand-file-name "~/.conda"))
  )
#+end_src

*   The rest

#+begin_src emacs-lisp

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/org/")

;; (setq lsp-idle-delay 0.500)
;; (setq shell-file-name "bash")
;; (setq shell-command-switch "-ic")


#+end_src


#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.

(package! impatient-mode)
(package! ox-gfm)
(package! ztree)
;; (unpin! mu4e)

;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)
#+end_src
